Facebook Phone Screen Questions:

==============================================================================

Question 1:

we have a git vertion control
   
        base
       commit1
       commit2
   commit3 commit3'
   commit4 commit4'
   
commit2 is parent of commit3, etc. Now give you two commits, 
find out the lowest common ancestor of these two commits.

for example, commit2 is the LCA of commit4 and commit3'

@interface Commit : NSObject<NSCopying>

@property (nonatomic, assign) NSInteger id;
@property (nonatomic, strong) Commit *parent;

@end

@implementation Commit

// ask interviewer if the class conform to NSCopying as a key of NSDictionary
- (id)copyWithZone:(NSZone *)zone {
	id copy = [[Commit allocWithZone:zone] init];
	return copy;
}

@end

// Ask interviewer: are these ids unique?
// Improvement: http://articles.leetcode.com/lowest-common-ancestor-of-a-binary-tree-part-ii/
// find the height of each node, then first iterate the deeper one until they are at same level
- (Commit *)findAncestorOfCommit:(Commit *) c1 andCommit:(Commit *)c2 {
	/* - after analyzing, I think this is a graph traversal + hash table question.
	   - we move two commits up together, and mark every commit on this path as visited
	   - if the commit meets the base commit, then we stop there
	   - if we find a commit that has already been visited before we meet the base commit,
	   	 then that commit is the LCA commit
	*/
	NSMutableDictionary<Commit *, NSNumber *> *visited = [NSMutableDictionary dictionary];
	while (c1 || c2) {
		if (c1 && visited[c1] != nil) return c1;
		if (c2 && visited[c2] != nil) return c2;
		if (c1) visited[c1] = @(YES);
		if (c2) visited[c2] = @(YES);
		c1 = c1.parent;
		c2 = c2.parent;
	}
	return nil;
}

==============================================================================

Question 2:

Give you a array of digits, only swap it once, in order to maximum the the number
that can be combined by these digits.

NOTICE: digits here are 0 to 9

For example, [4, 2, 1, 3, 5] is 42135, maximum number after one swap is 52134

// Ask interviewer: are these numbers unique or have duplicates
// Idea: sort the array first in decsend order; then compare digits one by one;
// when find the first digit not same, then find the "last" index of the digit, then swap
- (NSInteger)maximumNumberAfterOneSwap:(NSArray<NSNumber *> *)numbers {
    // sort number in descending order
    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:nil
                                                                     ascending:NO
                                                                      selector:@selector(compare:)];
    NSArray *sortedNumbers = [numbers sortedArrayUsingDescriptors:@[sortDescriptor]];
    
    // find the first number not same
    __block NSUInteger index = numbers.count;
    [numbers enumerateObjectsUsingBlock:^(NSNumber *num, NSUInteger idx, BOOL *stop) {
        if (num != sortedNumbers[idx]) {
            *stop = YES;
            index = idx;
        }
    }];
    
    __block NSUInteger swapIndex = numbers.count;
    NSNumber *destinationNumber = sortedNumbers[index];
    
    if (index != numbers.count) {
        [numbers enumerateObjectsWithOptions:NSEnumerationReverse
                                  usingBlock:^(NSNumber *num, NSUInteger idx, BOOL *stop) {
                                      if ([num isEqualToNumber:destinationNumber]) {
                                          swapIndex = idx;
                                          *stop = YES;
                                      }
                                  }];
    }
    NSMutableArray *mutableNumbers = [numbers mutableCopy];
    [mutableNumbers exchangeObjectAtIndex:index withObjectAtIndex:swapIndex];
    // combine numbers into a string
    NSString *maximumNumberStr = [mutableNumbers componentsJoinedByString:@""];
    return maximumNumberStr.integerValue;
}


==============================================================================

Question 3:

Give you a binary tree, each node keeps a integer value, calculate the average value of each layer.

@interface Tree : NSObject

@property (nonatomic, strong) Tree *left;
@property (nonatomic, strong) Tree *right;
@property (nonatomic, assign) NSInteger value;

@end

// Ask interviewer: sort output? binary search tree? fraction number?
- (NSArray *)averageValuesOfLayers:(Tree *)root {
    if (root == nil) return nil;
    // using NSMutableArray to simulate queue operations
    NSMutableArray<NSNumber *> *averageValues = [NSMutableArray array];
    NSMutableArray<Tree *> *queue = [NSMutableArray array];
    [queue addObject:root];
    
    while (queue.count) {
        // store the size of each layer
        NSUInteger size = queue.count;
        NSMutableArray *layer = [NSMutableArray array];
        for (NSUInteger i=0; i<size; i++) {
            Tree *node = queue[i];
            [layer addObject:@(node.value)];
        }
        // http://nshipster.com/kvc-collection-operators/
        NSNumber *layerAverageValue = [layer valueForKeyPath:@"@avg.doubleValue"];
        [averageValues addObject:layerAverageValue];
    }
    
    return averageValues;
}

==============================================================================

Question 4:

Output ALL paths of a binary tree

// Ask interviewer: binary search tree? balanced? from root to leaf or from leaf to root? output format?
- (NSArray<NSArray *> *)allPathsOfTree:(Tree *)root {
	if (root == nil) return [NSArray array];
	NSArray *leftPaths = [self allPathsOfTree:root.left];
	NSArray *rightPaths = [self allPathsOfTree:root.right];
	NSArray *subPaths = [leftPaths arrayByAddingObjectsFromArray:rightPaths];
	NSMutableArray *paths = [NSMutableArray array];
	for (NSArray *subPath in subPaths) {
		NSArray *path = [subPath arrayByAddingObject:@(root.value)];
		[paths addObject:path];
	}
	// NOTICE: this path is from "leaf" to "root"
	return paths;
}

==============================================================================

Question 5: Run Length Encoding

Given an input string, write a function that returns the Run Length Encoded string for the input string.

For example, if the input string is “wwwwaaadexxxxxx”, then the function should return “w4a3d1e1x6”.

// Ask interviewer: size of the string? capital letters? white spaces? how about single short letters?
- (NSString *)runLengthEncoding:(NSString *)input {
    if (!input || !input.length) return nil;
    NSString *encoded = [NSString string];
    unichar preC = [input characterAtIndex:0];
    NSInteger count = 1;
    for (NSUInteger i=1; i<input.length; i++) {
        unichar curC = [input characterAtIndex:i];
        if (preC == curC) count++;
        else {
            encoded = [encoded stringByAppendingFormat:@"%C", preC];
            encoded = [encoded stringByAppendingString:@(count).stringValue];
            // reset counter and previous character value
            count = 1;
            preC = curC;
        }
    }
    // append last one to the result string
    encoded = [encoded stringByAppendingFormat:@"%C", preC];
    encoded = [encoded stringByAppendingString:@(count).stringValue];
    return encoded;
}

==============================================================================

Question 6: Preorder verification question -> stack or in place

Given two pre-order traversal arrays of two "binary search tree" respectively, find first pair of non-matching leaves. Follow Up: If they are general binary trees instead of BSTs, could you solve it? give out your reason.

	 5
  3     7
1   4 6

5, 3, 1, 4, 7, 6 -> 5,[3, 1, 4],[7, 6] -> 5,[3, [1, 4]] [7 [6]] -> 5,[3, [[1], [4]]],[7, [6]]

// Similar to question 7
// Find the first "leaf" of first tree, and first "leaf" of second tree, then compare them

==============================================================================

Question 7:

Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree.
You may assume each number in the sequence is unique.

Follow up:
Could you do it using only constant space complexity?

// Idea: http://buttercola.blogspot.fi/2015/09/leetcode-verify-preorder-sequence-in.html
// Ask interviewer: what's the separator? size of array? balanced? Length 0, YES or NO?
// O(N^2), O(N)
- (BOOL)verifyPreorderBST:(NSArray *)bst {
    if (!bst || !bst.count) return NO;
    return [self verifyPreorderBST:bst start:0 end:bst.count-1];
}

- (BOOL)verifyPreorderBST:(NSArray *)bst start:(NSInteger)start end:(NSInteger)end {
    if (start >= end) return YES;
    NSNumber *root = bst[start];
    NSInteger i = start + 1;
    while (i < end && [root compare:bst[i]] == NSOrderedDescending) i++;
    NSInteger j = i;
    while (j < end && [root compare:bst[j]] == NSOrderedAscending) {
        j++;
    }
    if (j <= end ) return NO;
    return [self verifyPreorderBST:bst start:start+1 end:i-1] &&
    [self verifyPreorderBST:bst start:i end:end];
}

- (BOOL)verifyPreorderBSTWithStack:(NSArray<NSNumber *> *)preorder {
    if (!preorder || !preorder.count) return NO;
    
    NSMutableArray<NSNumber *> *stack = [NSMutableArray array];
    NSInteger max = NSIntegerMin;
    for (NSInteger i=0; i<preorder.count; i++) {
        NSInteger num = preorder[i].integerValue;
        if (num < max) return NO;
        
        while (stack.count > 0 && num > stack.lastObject.integerValue) {
            max = stack.lastObject.integerValue;
            [stack removeLastObject];
        }
        
        [stack addObject:@(num)];
    }
    return YES;
}

==============================================================================

Question 8: K Cloest Points

Given an array containing N points find the K closest points to the origin in the 2D plane. You can assume K is much smaller than N and N is very large.

// Traditional Quick Select question 
// https://en.wikipedia.org/wiki/Quickselect
// http://www.knowstack.com/sorting-algorithms-in-objective-c/
// Quick Select O(N), worse O(N^2)

/*
Quickselect uses the same overall approach as quicksort, choosing one element as a pivot and partitioning the data in two based on the pivot, accordingly as less than or greater than the pivot. However, instead of recursing into both sides, as in quicksort, quickselect only recurses into one side – the side with the element it is searching for. This reduces the average complexity from O(n log n) to O(n), with a worst case of O(n^2).
*/
// Ask Interviewer: point format? how about k = 0? how about k > points.count? how to select pivot, random or last // one?

- (NSArray<NSValue *> *)kCloestPoints:(NSUInteger)k fromPoints:(NSMutableArray<NSValue *> *)points {
    if (!points || !points.count || points.count < k) return nil;
    return [self kCloestPoints:k fromPoints:points start:0 end:points.count-1];
}

- (NSArray<NSValue *> *)kCloestPoints:(NSUInteger)k fromPoints:(NSMutableArray<NSValue *> *)points
                                start:(NSUInteger)start end:(NSUInteger)end {
	if (start == end) return [points copy];
    // http://stackoverflow.com/questions/35758588/maximum-return-value-of-arc4random
    NSUInteger selectedPivot = arc4random() % (end-start+1);
    NSUInteger pivotIndex = [self partition:points start:start end:end pivot:selectedPivot];
    if (pivotIndex == k) return [points subarrayWithRange:NSMakeRange(0, k)];
    if (pivotIndex > k) return [self kCloestPoints:k fromPoints:points
                                             start:start end:pivotIndex-1];
    else return [self kCloestPoints:k fromPoints:points
                              start:pivotIndex+1 end:end];
}

- (NSUInteger)partition:(NSMutableArray<NSValue *> *)points
                  start:(NSUInteger)start end:(NSUInteger)end
                  pivot:(NSUInteger)pivot {
    // choose last one as the pivot value
    NSUInteger pivotIndex = pivot;
    NSUInteger pivotDistance = [self distanceToOriginFromPoint:points[pivotIndex].pointValue];
    // move pivot value to end
    [points exchangeObjectAtIndex:pivotIndex withObjectAtIndex:end];
    for (NSUInteger i=start; i<end-1; i++) {
        // NOTICE: we should use CGPointValue for iOS
        NSUInteger distance = [self distanceToOriginFromPoint:points[i].pointValue];
        if (distance < pivotDistance) {
            [points exchangeObjectAtIndex:pivotIndex withObjectAtIndex:i];
            pivotIndex++;
        }
    }
    [points exchangeObjectAtIndex:pivotIndex withObjectAtIndex:end];
    return pivotIndex;
}

- (NSUInteger)distanceToOriginFromPoint:(CGPoint)point {
    return point.x*point.x + point.y*point.y;
}

==============================================================================

Question 9: Convert a given Binary Tree to Doubly Linked List

// About __autoreleasing:
// http://stackoverflow.com/questions/8814718/handling-pointer-to-pointer-ownership-issues-in-arc

// http://www.geeksforgeeks.org/convert-a-given-binary-tree-to-doubly-linked-list-set-4/

/* Given a Binary Tree (Bt), convert it to a Doubly Linked List(DLL). The left and right pointers in nodes are to be used as previous and next pointers respectively in converted DLL. The order of nodes in DLL must be same as "In-Order" of the given Binary Tree. The first node of Inorder traversal (left most node in BT) must be head node of the DLL. */

- (Tree *)doubleLinkedListFromBinaryTree:(Tree *)root {
	if (root == nil) return nil;
	if (root.left) {
		Tree *left = [self doubleLinkedListFromBinaryTree:root.left];
		Tree *leftTail = [self findTailOfList:left];
		leftTail.right = root;
		root.left = leftTail;
	}
	if (root.right) {
		Tree *right = [self doubleLinkedListFromBinaryTree:root.right];
		Tree *rightHead = [self findHeadOfList:right];
		root.right = rightHead;
		rightHead.left = root;
	}
	return root;
}

- (Tree *)findHeadOfList:(Tree *)node {
	if (!node) return nil;
	while(node->left) node = node->left;
	return node;
}

- (Tree *)findTailOfList:(Tree *)node {
	if (!node) return nil;
	while(node->right) node = node->right;
	return node;
}

- (Tree *)simpleDoubleLinkedListFromBinaryTree:(Tree *)root {
	Tree *head = nil;
	[self rightToLeftBuilder:root head:&head];
	return head;
}

- (void)rightToLeftBuilder:(Tree *)root head:(Tree * __autoreleasing *)head {
	// base case
	if (root == nil) return nil;
	[self rightToLeftBuilder:root.right head:head];
	
	root.right = *head;
	if (*head != nil) (*head).left = root;
	*head = root;
	
	[self rightToLeftBuilder:root.left head:head];
}

==============================================================================

Question 10: Lowest Common Ancestor of a Binary Tree
http://articles.leetcode.com/lowest-common-ancestor-of-a-binary-tree-part-i/

Given a binary tree, find the lowest common ancestor of two given nodes in the tree.

// Ask interviewer: general binary tree or BST? size? LCA of NULL and non-NULL? value unique?
// O(N^2) for worst case
- (Tree *)LCAOfBinaryTree:(Tree *)root node1:(Tree *)node1 node2:(Tree *)node2 {
	if (!root || !node1 || !node2) return nil;
	if (root == node1 || root == node2) return root;
	BOOL node1InLeft = [self findNode:node1 inTree:root.left];
	BOOL node2InLeft = [self findNode:node2 inTree:root.left];
	if (node1InLeft != node2InLeft) return root;
	if (node1InLeft) return [self LCAOfBinaryTree:root.left node1:node1 node2:node2];
	return [self LCAOfBinaryTree:root.right node1:node1 node2:node2];
}

- (BOOL)findNode:(Tree *)node inTree:(Tree *)root {
	if (root == nil || node == nil) return NO;
	if (node == root) return YES;
	return [self findNode:node inTree:root.left] ||
		   [self findNode:node inTree:root.right];
}

// O(N) worst case
- (Tree *)bottomUpLCAOfBinaryTree:(Tree *)root node1:(Tree *)node1 node2:(Tree *)node2 {
	if (root == nil) return nil;
	if (root == node1 || root == node2) return root;
	Tree *foundL = [self bottomUpLCAOfBinaryTree:root.left node1:node1 node2:node2];
	Tree *foundR = [self bottomUpLCAOfBinaryTree:root.right node1:node1 node2:node2];
	if (foundL && foundR) return root;
	return foundL ? foundL : foundR;
}

==============================================================================

Question 11: Sort Colors I

https://leetcode.com/problems/sort-colors/?tab=Solutions

Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Note:
You are not suppose to use the library's sort function for this problem.

// we can write quick sort. 
// Two Pass Solution: counting sort
- (void)twoPassSortColors:(NSMutableArray<NSNumber *> *)colors {
    NSUInteger counter[3];
    for (NSUInteger i=0; i<colors.count; i++) {
        counter[colors[i].unsignedIntegerValue]++;
    }
    for (NSUInteger i=0, j=0; i<colors.count && j<3; i++) {
        if (counter[j] > 0) {
            colors[i] = @(j);
            counter[j]--;
        } else {
            j++;
        }
    }
}

// One Pass In-Place Solution: three pointer, similar to move zeros, but with three pointers
// 0 2 1 2 0 2 1 2
- (void)onePassSortColors:(NSMutableArray<NSNumber *> *)colors {
    NSUInteger zero = 0, one = 0, two = colors.count-1;
    for (; one <= two; one++) {
        if ([colors[one] isEqualToNumber:@(0)]) {
            [colors exchangeObjectAtIndex:zero withObjectAtIndex:one];
            zero++;
        } else if ([colors[one] isEqualToNumber:@(2)]) {
            [colors exchangeObjectAtIndex:two withObjectAtIndex:one];
            // NOTICE: when color is 2, then go back one index. the index will come back in next loop and stay here
            one--;
            two--;
        }
    }
}

// One Pass Tricky In-Place Solution
- (void)onePassTrickySortColors:(NSMutableArray<NSNumber *> *)colors {
    NSInteger zero = -1, one = -1, two = -1;
    for (NSUInteger i=0; i<colors.count; i++) {
        if ([colors[i] isEqualToNumber:@(0)]) {
            colors[++two] = @(2); colors[++one] = @(1); colors[++zero] = @(0);
        } else if ([colors[i] isEqualToNumber:@(1)]) {
            colors[++two] = @(2); colors[++one] = @(1);
        } else if ([colors[i] isEqualToNumber:@(2)]) {
            colors[++two] = @(2);
        }
    }
}

==============================================================================

Question 12: Sort Colors II

Given an array of n objects with k different colors (numbered from 1 to k), sort them so that objects of the same color are adjacent, with the colors in the order 1, 2, ... k.

Notice: You are not suppose to use the library's sort function for this problem.

// Best solution, O(NLog(k))
- (void)sortColors2:(NSMutableArray<NSNumber *> *)colors k:(NSUInteger)k {
	// key idea: binary 
	if (!colors) return;
	[self rainbowSort:colors start:0 end:colors.count-1 colorFrom:1 colorTo:k];
}

- (void)rainbowSort:(NSMutableArray<NSNumber *> *)colors
			  start:(NSUInteger)start end:(NSUInteger)end 
		  colorFrom:(NSUInteger)colorFrom colorTo:(NSUInteger)colorTo {
	if (start >= end) return;
	if (colorFrom == colorTo) return;
	// find the middle value
	NSUInteger colorMid = colorFrom + (colorTo-colorFrom)/2;
	NSUInteger s=start, e=end;
	while (s <= e) {
		while (s<=e && colors[s].unsignedIntegerValue <= colorMid) s++;
		while (s<=e && colors[e].unsignedIntegerValue > colorMid) e--;
		if (s <= e) {
			[colors exchangeObjectAtIndex:s withObjectAtIndex:e];
			s++;
			e--;
		}
	}
	[self rainbowSort:colors start:start end:e colorFrom:colorFrom colorTo:colorMid];
	[self rainbowSort:colors start:s end:end colorFrom:colorMid+1 colorTo:colorTo];
}

==============================================================================

Question 13: Remove Invalid Parentheses

Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.

Note: The input string may contain letters other than the parentheses ( and ).

Examples:
"()())()" -> ["()()()", "(())()"]
"(a)())()" -> ["(a)()()", "(a())()"]
")(" -> [""]

// BFS thinking: check current level is valid or not.
// - if YES, then add to result and mark this level to be "found". 
// (Here we need to be careful that there maybe other valid string in this level, we need to add them all) 
// - if NO, go deeper level
// http://www.geeksforgeeks.org/remove-invalid-parentheses/
// https://leetcode.com/problems/remove-invalid-parentheses/?tab=Solutions
// Ask interviewer: input format? is input valid?
- (NSArray<NSString *> *)removeInvalidParentheses:(NSString *)s {
    if (s == nil) return nil;
    NSMutableArray<NSString *> *results = [NSMutableArray array];
    NSMutableArray<NSString *> *queue = [NSMutableArray array];
    NSMutableSet<NSString *> *visited = [NSMutableSet set];
    BOOL found = NO;
    [queue addObject:s];
    while (queue.count) {
        NSString *front = queue.firstObject;
        [queue removeObjectAtIndex:0];
        if ([self isValid:front]) {
            found = YES;
            [results addObject:front];
        }
        // if this node is valid, it's children MUST be invalid, due to removing one more parenthese.
        if (found) continue;
        for (NSUInteger i=0; i<front.length; i++) {
            if (![self isParenthesis:[front characterAtIndex:i]]) continue;
            NSMutableString *mutableFront = [front mutableCopy];
            [mutableFront deleteCharactersInRange:NSMakeRange(i,1)];
            if (![visited containsObject:mutableFront]) {
                [visited addObject:mutableFront];
                [queue addObject:mutableFront];
            }
        }
    }
    return results;
}

- (BOOL)isValid:(NSString *)s {
    NSInteger count = 0;
    for (NSUInteger i=0; i<s.length; i++) {
        if ([s characterAtIndex:i] == '(') {
            count++;
        } else if ([s characterAtIndex:i] == ')') {
            count--;
        }
        if (count < 0) return NO;
    }
    return YES;
}

- (BOOL)isParenthesis:(unichar)c {
    return c == '(' || c == ')';
}

==============================================================================

Question 14: Number Of Islands

Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example 1:

11110
11010
11000
00000
Answer: 1

Example 2:

11000
11000
00100
00011
Answer: 3

// Very tradiional DFS question.
// find '1's, each time we find unvisited '1', do DFS to mark all neighbour '1's as visited, and count++
// http://www.jiuzhang.com/solutions/number-of-islands/
-(NSUInteger)dfsNumIslands:(NSArray<NSArray<NSNumber *> *> *)grid {
    NSUInteger m = grid.count;
    if (m == 0) return 0;
    NSUInteger n = grid[0].count;
    NSUInteger count = 0;
    NSMutableSet<NSValue *> *visited = [NSMutableSet set];
    for (NSUInteger i=0; i<m; i++) {
        for (NSUInteger j=0; j<n; j++) {
            // NOTICE: should be valueWithCGPoint in iOS
            NSValue *pos = [NSValue valueWithPoint:CGPointMake(i, j)];
            if (![visited containsObject:pos]) {
                count++;
                [self DFS:grid i:i j:j m:m n:n visited:visited];
            }
        }
    }
    return count;
}

// https://www.tutorialspoint.com/objective_c/objective_c_passing_arrays_to_functions.htm
-(void)DFS:(NSArray<NSArray<NSNumber *> *> *)grid i:(NSInteger)i j:(NSInteger)j
         m:(NSUInteger)m n:(NSUInteger)n visited:(NSMutableSet<NSValue *> *) visited {
    if (i<0 || i>m-1 || j<0 || j>n-1) return;
    if ([grid[i][j] isEqualToNumber:@(0)]) return;
    // check if this land has been visited or not
    // NOTICE: should be valueWithCGPoint in iOS
    NSValue *pos = [NSValue valueWithPoint:CGPointMake(i, j)];
    if ([visited containsObject:pos]) return;
    // if not visited yet, mark it as visited
    [visited addObject:pos];
    // now go deeper to it's neighbors: up, down, left, right
    [self DFS:grid i:i+1 j:j m:m n:m visited:visited];
    [self DFS:grid i:i j:j+1 m:m n:m visited:visited];
    [self DFS:grid i:i-1 j:j m:m n:m visited:visited];
    [self DFS:grid i:i j:j-1 m:m n:m visited:visited];
}

==============================================================================

Question 15: Find Minimum in Rotated Sorted Array I && II

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).Find the minimum element.

NOTICE: You may assume no duplicate exists in the array.
FOLLOW UP: What if duplicates are allowed? Would this affect the run-time complexity? How and why?

// Traditional binary search question
// Ask interviewer: duplicates? all positive? how about nil pointer handling?
// Check two element case [2, 1] and [1, 2]
// https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/?tab=Solutions
- (NSNumber *)findMin:(NSArray<NSNumber *> *)nums {
    NSParameterAssert(nums);	// prevent nums to be nil
    NSUInteger left = 0, right = nums.count-1;
    while (left < right) {
        NSUInteger mid = left + (right-left) / 2;
        if ([nums[mid] compare:nums[right]] == NSOrderedDescending ||
            [nums[mid] compare:nums[right]] == NSOrderedSame) {
            left = mid+1;
        } else {
            right = mid;
        }
    }
    return nums[left];
}

// [1, 2, 2, 2, 3, 1, 1, 1]
// worst case: [1, 1, 1, 1, 1, 1, ...., 1], from O(Log(N)) drops to O(N)
// http://www.jiuzhang.com/solutions/find-minimum-in-rotated-sorted-array-ii/
- (NSNumber *)findMinWithDuplicates:(NSArray<NSNumber *> *)nums {
    NSParameterAssert(nums);
    NSUInteger left = 0, right = nums.count-1;
    while (left < right) {
        NSUInteger mid = left + (right - left)/2;
        if ([nums[mid] compare:nums[right]] == NSOrderedDescending) {
            left = mid+1;
        } else if ([nums[mid] compare:nums[right]] == NSOrderedAscending){
            right = mid;
        } else { // equal
            right--; // when middle value equals to right value, just move right to left by 1
        }
    }
    return nums[left];
}

==============================================================================

Question 16: Paint House I
 
There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.

The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses.

// Dynamic Programming question
// After thinking, this question is similar to "best time of sell stock" question
// For each house, we have three choices: paint red, blue and green
// we use three arrays for tracking three DP lines
// http://www.cnblogs.com/grandyang/p/5319384.html
- (NSUInteger)minCost:(NSUInteger [][3])costs n:(NSUInteger)n {
	// three status for painting ith house
	NSUInteger red[n+1], blue[n+1], green[n+1];
	red[0] = blue[0] = green[0] = NSUIntegerMax;
	for (NSUInteger i=1; i<n+1; i++) {
		// if the ith house painted into red color, then (i-1)th house must be blue or green
		red[i] = MIN(blue[i-1]+costs[i][0], green[i-1]+costs[i][0]);
		blue[i] = MIN(red[i-1]+costs[i][1], green[i-1]+costs[i][1]);
		green[i] = MIN(red[i-1]+costs[i][2], blue[i-1]+costs[i][2]);
	}
	return MIN(red[n], MIN(blue[n], green[n]));
}

- (NSUInteger)minCostInPlace:(NSUInteger [][3])costs n:(NSUInteger)n {
	for (NSUInteger i=1; i<n; i++) {
		costs[i][0] += MIN(costs[i-1][1], costs[i-1][2]);
		costs[i][1] += MIN(costs[i-1][0], costs[i-1][2]);
		costs[i][2] += MIN(costs[i-1][0], costs[i-1][1]);
	}
	return MIN(MIN(costs[n-1][0], costs[n-1][1]), costs[n-1][2]);
}

==============================================================================

Question 17: Paint House II
 
There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.

The cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses.

Follow up:
Could you solve it in O(nk) runtime?

https://discuss.leetcode.com/topic/22580/ac-java-solution-without-extra-space
http://www.jiuzhang.com/solutions/paint-house-ii/
// Idea: dynamic programming, cache previous minimum and second minimum {color id, cost}
// if current color id equals to previous minimum, then use second minimum; Otherwise, use previous minimum

@interface PreviousMinimumCost : NSObject

@property (nonatomic, assign) NSUInteger color;
@property (nonatomic, assign) NSUInteger cost;

+ (instancetype)empty;
+ (instancetype)cost:(NSUInteger)cost color:(NSUInteger)color;

@end

- (NSUInteger)minCostII:(NSUInteger **)costs n:(NSUInteger)n k:(NSUInteger)k {
    NSUInteger dp[n+1][k];
    memset(dp, 0, sizeof(dp));
    // "now" calculates three most minimum cost for ith house among k colors
    // then "last" store these value for calculating (i+1)th house
    NSMutableArray<PreviousMinimumCost *> *now = [NSMutableArray array];
    NSArray<PreviousMinimumCost *> *last = nil;
    [now addObject:[PreviousMinimumCost empty]];
    [now addObject:[PreviousMinimumCost empty]];
    [now addObject:[PreviousMinimumCost empty]];
    
    for (NSUInteger i=1; i<=n; i++) {
        last = [now copy];
        now[0] = [PreviousMinimumCost empty];
        now[1] = [PreviousMinimumCost empty];
        for (NSUInteger j=0; j<k; j++) {
            // current color is different from last color
            if (j != last[0].color) {
                dp[i][j] = dp[i-1][last[0].color] + costs[i-1][j];
            } else {
                dp[i][j] = dp[i-1][last[1].color] + costs[i-1][j];
            }
            now[2] = [PreviousMinimumCost cost:dp[i][j] color:j];
            NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@"cost" ascending:NO];
            [now sortUsingDescriptors:@[sortDescriptor]];
        }
    }
    return now[0].cost;
}

==============================================================================

Question 18: Convert Sorted List to Binary Search Tree

Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

@interface ListNode : NSObject

@property(nonatomic, strong) ListNode *next;
@property(nonatomic, assign) NSInteger value;

@end

// Idea: double runner, find middle value, then split the linked list into two parts, recursion
// Ask interviewer: type of value? size of linked list? duplicates?
// NOTICE: DO NOT change the original list.
// [1, 2, 3, 4, 5, 6, 7]
// https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/?tab=Solutions
// http://www.jiuzhang.com/solutions/convert-sorted-list-to-binary-search-tree/
- (Tree *)sortedListToBST:(ListNode *)head {
    if (head == nil) return nil;
    return [self toBST:head tail:nil];
}

- (Tree *)toBST:(ListNode *)head tail:(ListNode *)tail {
    if (head.next == tail) return [Tree nodeWithValue:head.value];
    // create runners
    ListNode *slow = head;
    ListNode *fast = head;
    while (fast != tail && fast.next != tail) {
        fast = fast.next.next;
        slow = slow.next;
    }
    // now slow is the root of the BST
    Tree *root = [Tree nodeWithValue:slow.value];
    root.left = [self toBST:head tail:slow];
    root.right = [self toBST:slow.next tail:tail];
    return root;
}

==============================================================================

Question 19: Coin Change

You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:
coins = [1, 2, 5], amount = 11
return 3 (11 = 5 + 5 + 1)

Example 2:
coins = [2], amount = 3
return -1.

Note:
You may assume that you have an infinite number of each kind of coin.

// Traditional Dynamic Programming question
// Tricky part:
// - the index of DP[] stands for the target total amount; 
// - the value of DP[] stands for the minimum count of coins
// Ask interviewer: coins sorted? coin value type? target amount size?
// https://leetcode.com/problems/coin-change/?tab=Solutions
- (NSInteger)coinChange:(NSArray<NSNumber *> *)coins amount:(NSUInteger)amount {
    // NOTICE: how about amount == NSUIntegerMax ? discuss with interviewer
    // variable length C array should not be initialized with "{ value }";
    NSUInteger dp[amount+1];
    memset(dp, amount+1, amount+1);
    dp[0] = 0;
    for (NSUInteger i=1; i<=amount; i++) {
        NSUInteger n = coins.count;
        for (NSUInteger j=0; j<n; j++) {
            NSUInteger curC = coins[j].unsignedIntegerValue;
            if (curC <= i) dp[i] = MIN(dp[i], dp[i-curC]+1);
        }
    }
    return dp[amount] <= amount ?: -1;
}

==============================================================================

Question 20: Divide Two Integers

Divide two integers without using multiplication, division and mod operator.
If it is overflow, return MAX_INT.

// Ask interviewer: positive or negative? zero?
// Naive solution: minus dividend and dividor and count times.
// Better solution: binary search. dividor << 1, which means dividend * 2, until dividend < dividor
// each time we double the dividor => binary search => Log(N)
// Treat dividers as sorted array
// NOTICE: we need to handle corner cases 1) zero dividor 2) minus integer
// 25 / 3 -> 25 / 6 -> 25 / 12 -> 25 / 24
// https://leetcode.com/problems/divide-two-integers/?tab=Solutions
// http://www.jiuzhang.com/solutions/divide-two-integers/

- (NSInteger)divide:(NSInteger)dividend dividor:(NSInteger)dividor {
 	// overflow cases
	if (dividor == 0 || (dividend == NSIntegerMin && dividor == -1)) return NSIntegerMax;
	// using XOR to shorten this checking
	NSInteger sign = (dividend > 0) ^ (dividor > 0) ? -1 : 1;
	NSUInteger dvd = ABS(dividend);
	NSUInteger dvs = ABS(dividor);
	NSUInteger result = 0;
	while(dvd >= dvs) {
		NSInteger tmp = dvs;
		// when dividend > dividor, the result is at lease 1
		NSUInteger multiple = 1;
		// times dividor by 2, also times the multiple by 2
		while(dvd >= (tmp << 1)) {
			tmp <<= 1;
			multiple <<= 1;
		}
		dvd -= tmp;
		result += multiple;
	}
	return sign == 1 ? result : -result;
}

==============================================================================

Question 21: Move Zeroes

Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.
For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].
Note: You must do this in-place without making a copy of the array. Minimize the total number of operations.

// Very traditional question, MUST do in perfect way.
// Ask interviewer: how about nil ? zero count ?
// http://www.jiuzhang.com/solutions/move-zeroes/
- (void)moveZeros:(NSMutableArray<NSNumber *> *)nums {
    NSParameterAssert(nums);
    NSUInteger zero = 0;
    for (NSUInteger nonZero = 0; nonZero<nums.count; nonZero++) {
        if (![nums[nonZero] isEqualToNumber:@(0)]) {
            [nums exchangeObjectAtIndex:nonZero withObjectAtIndex:zero];
            zero++;
        }
    }
}

==============================================================================

Question 22: Add and Search Word - Data structure design

Design a data structure that supports the following two operations:

void addWord(word)
bool search(word)

search(word) can search a literal word or a regular expression string containing only letters a-z or '.'. A '.' means it can represent any one letter.

For example:

addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true

Note: You may assume that all words are consist of lowercase letters a-z.

// Ask interviewer: how many words? how offen APIs get called?
// Naive solution: use hash set to keep each word. If there are too many words, this solution is not scalable.
// Better solution: When we meet "add string" or "search string", "Trie" is the data structure to use
// We need to create TrieNode and Trie helper class
// https://leetcode.com/problems/add-and-search-word-data-structure-design/?tab=Solutions

#pragma mark - TrieNode

@interface TrieNode : NSObject

@property(nonatomic, assign) BOOL isWord;

+ (instancetype)node;
- (BOOL)hasChild:(unichar)c;
- (TrieNode *)getChild:(unichar)c;
- (void)setChild:(unichar)c withNode:(TrieNode *)node;

@end

@interface TrieNode ()

@property(nonatomic, strong) NSMutableDictionary<NSString *, TrieNode *> *children;

@end

@implementation TrieNode

+ (instancetype)node {
    TrieNode *node = [self new];
    return node;
}

- (instancetype)init {
    self = [super init];
    if (self) {
        _children = [NSMutableDictionary dictionary];
        _isWord = NO;
    }
    return self;
}

- (BOOL)hasChild:(unichar)c {
    NSString *key = [self stringWithUnichar:c];
    return [self.children objectForKey:key] != nil;
}

- (TrieNode *)getChild:(unichar)c {
    NSString *key = [self stringWithUnichar:c];
    return [self.children objectForKey:key];
}

- (void)setChild:(unichar)c withNode:(TrieNode *)node {
    NSString *key = [self stringWithUnichar:c];
    [self.children setObject:node forKey:key];
}

- (NSString *)stringWithUnichar:(unichar)c {
    return [NSString stringWithFormat:@"%C", c];
}

@end

#pragma mark - Trie

@interface Trie : NSObject

@property (nonatomic, strong) TrieNode *root;

+ (instancetype)trie;
- (void)addWord:(NSString *)word;
- (BOOL)search:(NSString *)word;

@end

@implementation Trie

+ (instancetype)trie {
    Trie *theTrie = [self new];
    theTrie.root = [TrieNode node];
    return theTrie;
}

- (void)addWord:(NSString *)word {
    if (!word) return;
    // insert word characters one by one, change current node following the path
    TrieNode *curNode = self.root;
    for (NSUInteger i=0; i<word.length; i++) {
        unichar c = [word characterAtIndex:i];
        // if there isn't word with this character, create new node.
        // otherwise, just get the existing node.
        if (![curNode hasChild:c]) {
            TrieNode *newNode = [TrieNode node];
            [curNode setChild:c withNode:newNode];
        }
        curNode = [curNode getChild:c];
    }
    // mark this node as the end of a complete word.
    curNode.isWord = YES;
}

- (BOOL)search:(NSString *)word {
    if (!word) return NO;
    return [self search:word root:self.root];
}

- (BOOL)search:(NSString *)word root:(TrieNode *)root {
    if (word.length == 0 && root.isWord) return YES;
    unichar c = [word characterAtIndex:0];
    if (c != '.' && [root hasChild:c]) {
        [self search:[word substringWithRange:NSMakeRange(0,1)] root:[root getChild:c]];
    } else if (c == '.') {
        for (NSUInteger i=0; i<26; i++) {
            c = 'a'+i;
            BOOL found = [self search:[word substringWithRange:NSMakeRange(0,1)] root:[root getChild:c]];
            if (found) return YES;
        }
    }
    return NO;
}

@end

#pragma mark - WordDictionary

@interface WordDictionary : NSObject

@property (nonatomic, strong) Trie *trie;

@end

@implementation WordDictionary

- (instancetype)init {
    self = [super init];
    if (self) {
        _trie = [Trie trie];
    }
    return self;
}

- (void)addWord:(NSString *)word {
    [self.trie addWord:word];
}

- (BOOL)search:(NSString *)word {
    return [self.trie search:word];
}

@end

==============================================================================

Question 23: 3Sum

Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note: The solution set must not contain duplicate triplets.

For example, given array S = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]

Similar Questions:
- 3Sum Cloest: https://leetcode.com/problems/3sum-closest/?tab=Solutions
- 3Sum Small: http://www.cnblogs.com/grandyang/p/5235086.html
- NOTICE: 1) for 3Sum Cloest and 3Sum Small, we don't need to remove duplicates
- 2)for 3Sum Cloest, remember to use "ABS" for calculating the value

// By brute force, this question can be solved with O(N^3)
// Better idea: we sort the array first, then using three pointers (one head, one tail, and one mid)
// Then we reduce the time complexity into O(N^2 + NLog(N))
// NOTICE: remove duplicates by moving pointers until no duplicates, then calculate
// Ask interviewer: duplicates in array? order of output?
// http://www.jiuzhang.com/solutions/3sum/
// https://leetcode.com/problems/3sum/?tab=Solutions

- (NSArray<NSArray<NSNumber *> *> *)threeSum:(NSArray<NSNumber *> *)nums {
	if (!nums) return nil;

    NSMutableArray<NSNumber *> *sortedNums = [NSMutableArray arrayWithArray:nums];
    NSSortDescriptor *descriptor = [NSSortDescriptor sortDescriptorWithKey:nil ascending:YES];
    [sortedNums sortUsingDescriptors:@[descriptor]];
    
    NSUInteger size = nums.count;
    NSMutableArray<NSArray<NSNumber *> *> *results = [NSMutableArray array];
    
    for (NSUInteger start=0; start<size-2; start++) {
        // if found duplicates, ignore and continue
        if (start > 0 && [sortedNums[start] isEqualToNumber:sortedNums[start-1]]) continue;
        NSUInteger mid = start+1;
        NSUInteger end = size-1;
        NSInteger target = -sortedNums[start].integerValue;
        while (mid < end) {
            if (sortedNums[mid].integerValue + sortedNums[end].integerValue == target) {
                [results addObject:@[sortedNums[start], sortedNums[mid], sortedNums[end]]];
                mid++; end--;
                // now skip duplicates
                while (mid < end && sortedNums[mid] == sortedNums[mid-1]) mid++;
                while (mid < end && sortedNums[end] == sortedNums[end+1]) end--;
            } else if (sortedNums[mid].integerValue + sortedNums[end].integerValue < target) {
                mid++;
            } else {
                end--;
            }
        }
    }
    return results;
}

==============================================================================

Question 24: 4Sum I

Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note: The solution set must not contain duplicate quadruplets.

For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]

// Similar to 3Sum, but now we use two front points instead of one
// Brute Force: O(N^4)
// Better idea: sort and reach N^3 + NLog(N)
// http://www.jiuzhang.com/solutions/4sum/

- (NSArray<NSArray<NSNumber *> *> *)fourSum:(NSArray<NSNumber *> *)nums target:(NSInteger)target {
    if (!nums) return nil;
    
    NSMutableArray<NSNumber *> *sortedNums = [NSMutableArray arrayWithArray:nums];
    NSSortDescriptor *descriptor = [NSSortDescriptor sortDescriptorWithKey:nil ascending:YES];
    [sortedNums sortUsingDescriptors:@[descriptor]];
    
    NSMutableArray<NSArray *> *results = [NSMutableArray array];
    NSUInteger size = nums.count;
    for (NSUInteger first=0; first<size-3; first++) {
        if (first > 0 && [sortedNums[first] isEqualToNumber:sortedNums[first-1]]) continue;
        for (NSUInteger second = first+1; second < size-2; second++) {
            if (second > first+1 && [sortedNums[second] isEqualToNumber:sortedNums[second-1]]) continue;
            NSInteger sum = target - sortedNums[first].integerValue - sortedNums[second].integerValue;
            NSUInteger third = second+1;
            NSUInteger fourth = size-1;
            while (third < fourth) {
                if (sortedNums[third].integerValue + sortedNums[fourth].integerValue == sum) {
                    [results addObject:@[sortedNums[first], sortedNums[second],
                                         sortedNums[third], sortedNums[fourth]]];
                    third++; fourth--;
                    while (third < fourth && [sortedNums[third] isEqualToNumber:sortedNums[third-1]]) third++;
                    while (third < fourth && [sortedNums[fourth] isEqualToNumber:sortedNums[fourth-1]]) fourth--;
                } else if (sortedNums[third].integerValue + sortedNums[fourth].integerValue < sum) {
                    third++;
                } else {
                    fourth--;
                }
            }
        }
    }
    return results;
}

==============================================================================

Question 25: 4Sum II

Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.

To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.

Example:

Input:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

Output:
2

Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0

// Brute force: O(N^4) -> too slow
// Better idea: we change this to 2Sum question. first get sum of A and B, and count them in a hash table
// Then calculate C + D, and find if target-(C+D) exists in hash table
// O(N^2)

- (NSUInteger) fourSumCountAmongA:(NSArray<NSNumber *> *)A B:(NSArray<NSNumber *> *)B
                              C:(NSArray<NSNumber *> *)C D:(NSArray<NSNumber *> *)D {
    NSParameterAssert(A && B && C && D);
    NSMutableDictionary<NSNumber *, NSNumber *> *count = [NSMutableDictionary dictionary];
    for (NSUInteger i=0; i<A.count; i++) {
        for (NSUInteger j=0; j<B.count; j++) {
            NSInteger sum = A[i].integerValue + B[j].integerValue;
            count[@(sum)] = @(count[@(sum)].integerValue + 1);
        }
    }
    
    NSUInteger result = 0;
    for (NSUInteger i=0; i<C.count; i++) {
        for (NSUInteger j=0; j<D.count; j++) {
            NSInteger sum = C[i].integerValue + D[j].integerValue;
            if (count[@(-sum)] && count[@(-sum)].integerValue > 0) {
                result++;
                count[@(-sum)] = @(count[@(-sum)].integerValue-1);
            }
        }
    }
    return result;
}

==============================================================================

Question 26: Print the pretty JSON strings

Pretty print a JSON object using proper indentation.

Every inner brace should increase one indentation to the following lines.
Every close brace should decrease one indentation to the same line and the following lines.
The indents can be increased with an additional ‘\t’

Example 1:

Input : {A:"B",C:{D:"E",F:{G:"H",I:"J"}}}
Output : 
{ 
    A:"B",
    C: 
    {
        D:"E",
        F:
        {
            G:"H",
            I:"J"
        }
    }
}

Example 2:

Input : ["foo", {"bar":["baz",null,1.0,2]}]
Output : 
[
    "foo",
    {
        "bar":
        [
            "baz",
            null,
            1.0,
            2
        ]
    }
]
[] and {} are only acceptable braces in this case.

Assume for this problem that space characters can be done away with.

Your solution should return a list of strings, where each entry corresponds to a single line. 
The strings should not have “\n” character in them.

// When we see string parsing question, stack is a good data structure to use.
// For this question, we don't use stack. we iterate from left to right, 
// increase indent for '{' or '[', create new line for ',', decrease indent for '}' and ']'
// Ask interviewers: is input valid? white space?
// http://qa.geeksforgeeks.org/3734/print-the-pretty-json-strings-facebook-microsoft
// One improvement is replacing all ' ' with '' at beginning.

- (NSArray<NSString *> *)prettyJSONString:(NSString *)json {
    if (!json) return nil;
    
    NSMutableArray<NSString *> *results = [NSMutableArray array];
    NSString *indent = [NSString string];
    
    for (NSUInteger i=0; i<json.length; i++) {
        unichar c = [json characterAtIndex:i];
        NSString *line = [NSString string];
        if (c == ' ') continue;
        if (c == '{' && c == '[') {
            line = [NSString stringWithFormat:@"%@%C", indent, c];
            indent = [indent stringByAppendingFormat:@"%c", '\t'];	// append new indent
        } else if (c == '}' && c == ']') {
            // A new string containing the characters of the receiver up to,
            // but not including, the one at anIndex.
            indent = [indent substringToIndex:indent.length-1];	// remove last indent
            line = [NSString stringWithFormat:@"%@%C", indent, c];
        } else if (c == ',' || c == ':') {
            line = [line stringByAppendingFormat:@"%C", c];
            line = [NSString stringWithFormat:@"%@%@,", indent, line];
        } else {
            // if the current character is non of above ones, then append it to line, and continue
            line = [line stringByAppendingFormat:@"%C", c];
            continue;
        }
        
        [results addObject:line];
        line = [NSString string];
    }
    return results;
}

==============================================================================

Question 26: Flatten Nested List Iterator

Given a nested list of integers, implement an iterator to flatten it.
Each element is either an integer, or a list -- whose elements may also be integers or other lists.

Example 1:
Given the list [[1,1],2,[1,1]],

By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].

Example 2:
Given the list [1,[4,[6]]],

By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].

// Ask interviewer: if no next, what to return?
// For this question, we can use Queue or Stack to solve. My solution is Queue solution.
// For Stack solution: http://www.jiuzhang.com/solutions/flatten-nested-list-iterator/

@interface NestedInteger : NSObject

- (BOOL)isInteger;
- (NSNumber *)getInteger;
- (NSArray<NestedInteger *> *)getList;

@end

@interface NestedInteractor : NSObject

- (NSNumber *)next;
- (BOOL)hasNext;

@end

@interface NestedInteractor ()

@property (nonatomic, strong) NSMutableArray<NSNumber *> *queue;
@property (nonatomic, strong) NSArray<NestedInteger *> *nums;
@property (nonatomic, assign) NSUInteger idx;

@end

@implementation NestedInteractor

- (instancetype)initWithNums:(NSArray<NestedInteger *> *)nums {
    self = [super init];
    if (self) {
        _queue = [NSMutableArray array];
        _nums = nums;
        _idx = 0;
    }
    return self;
}

- (NSNumber *)next {
    if ([self hasNext]) {
        if (self.queue.count) {
            NSNumber *front = self.queue.firstObject;
            [self.queue removeObjectAtIndex:0];
            return front;
        } else {
            [self push:self.nums[self.idx++]];
            return [self next];
        }
    }
    return nil;
}


- (BOOL)hasNext {
    return self.idx < self.nums.count || self.queue.count > 0;
}

#pragma mark - Private

- (void)push:(NestedInteger *)nestedInteger {
    if ([nestedInteger isInteger]) {
        [self.queue addObject:[nestedInteger getInteger]];
    } else {
        NSArray<NestedInteger *> *list = [nestedInteger getList];
        for (NSUInteger i=0; i<list.count; i++) {
            [self push:list[i]];
        }
    }
}

@end

==============================================================================

Question 27: Binary Tree Level Order Traversal

Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]

// Basic BFS question

- (NSArray<NSArray<NSNumber *> *> *)levelOrder:(Tree *)root {
	if (root == nil) return nil;
	
	NSMutableArray<Tree *> *queue = [NSMutableArray array];
	NSMutableArray<NSArray<NSNumber *> *> *results = [NSMutableArray array];
	
	[queue addObject:root];
	while (queue.count) {
		NSMutableArray<NSNumber *> *level = [NSMutableArray array];
		NSUInteger size = queue.count;
		for (NSUInteger i=0; i<size; i++) {
			Tree *node = queue.firstObject;
			[level addObject:@(node.value)];
			if (node.left) [queue addObject:node.left];
			if (node.right) [queue addObject:node.right];
		}
		// NOTICE: because NSMutableArray is not Queue, 
		// we CAN NOT remove object at index during iterating the array.
		// instead, we remove them together later.
		[queue removeObjectsInRange:NSMakeRange(0,size)];
		[results addObject:level];
	}
	return results;
}

==============================================================================

Question 28: Merge Sorted Array

Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.

// Ask interviewer: duplicates? input valid? ascending or descending
// We know that nums1 array has more than or equal m+n space, so we iterate based on nums2
// we put merged numbers into nums1 from back to front
// when all numbers from nums2 have been merged into nums1, then we just keep the rest numbers
// in nums1 at their place.

- (void)merge:(NSInteger *)nums1 and:(NSInteger *)nums2 m:(NSUInteger)m n:(NSUInteger)n {
    if (nums1 == nil || nums2 == nil || m == 0 || n == 0) return;
    NSInteger end1 = m-1, end2 = n-1, end = m+n-1;
    while (end2 >= 0) {
        if (end1 >= 0) {
            nums1[end--] = nums1[end1] > nums2[end2] ? nums1[end1--] : nums2[end2--];
        } else {
            nums1[end--] = nums2[end2--];
        }
    }
}

==============================================================================

Question 29: Balance parentheses in a string 

For example:
"(a)()" -> "(a)()"
"((bc)" -> "(bc)"
")))a((" -> "a"
"(a(b)" ->"(ab)" or "a(b)"
"(a(((b"
")))a((b)"

Follow up: do without using Stack

// http://www.1point3acres.com/bbs/thread-192179-1-1.html
// We can use stack for this question. Also, we can solve it without stack, by using counter.
// Ask interviewer: do we add to balance parentheses, or only remove? special cases? memory limitation?
// white space? input valid -> "(a(((b"? character set?
// Usually, "pair, unpair" question can be solved by counter easily.
// For this question, we need to remove redundent '(' and ')' seperately.
// So we iterate the string L -> R, and R -> L.
// TODO: one pass solution?

- (NSString *)balanceParentheses:(NSString *)input {
    // use stack to mark the index of '('. pop top when meeting ')'
    NSString *result = [self removeRightParentheses:input];
    result = [self removeLeftParentheses:result];
    return result;
}

- (NSString *)removeRightParentheses:(NSString *)input {
    NSInteger count = 0;
    NSMutableString *result = [NSMutableString string];
    for (NSInteger i=0; i<input.length; i++) {
        unichar c = [input characterAtIndex:i];
        [result appendFormat:@"%C", c];
        if (c == '(') count++;
        else if (c == ')') {
            if (count > 0) count--;
            else [result deleteCharactersInRange:NSMakeRange(input.length-1, 1)];
        }
    }
    return result;
}

- (NSString *)removeLeftParentheses:(NSString *)input {
    NSInteger count = 0;
    NSMutableString *result = [NSMutableString string];
    for (NSInteger i=input.length-1; i>=0; i--) {
        unichar c = [input characterAtIndex:i];
        [result insertString:[NSString stringWithFormat:@"%C", c] atIndex:0];
        if (c == ')') count++;
        else if (c == '(') {
            if (count > 0) count--;
            else [result deleteCharactersInRange:NSMakeRange(0, 1)];
        }
    }
    return result;
}

==============================================================================

Question 30: Decode Ways

A message containing letters from A-Z is being encoded to numbers using the following mapping:

'A' -> 1
'B' -> 2
...
'Z' -> 26

Given an encoded message containing digits, determine the total number of ways to decode it.

For example,

Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).
The number of ways decoding "12" is 2.

Follow-up: 1) output all decoded results 2) constant space

// Dynamic Programming + Backtracking all results
// Ask interviewer: range of digits? input order? for follow-up, output order? input always digits?
// first digit is '0'?
// For Follow-up 1), if we want to print out all results, using recursion and copy result string in each
// recursive call would be a solution.
// http://www.jiuzhang.com/solutions/decode-ways/
// https://leetcode.com/problems/decode-ways/?tab=Solutions

- (NSUInteger)numDecodingsDP:(NSString *)s {
    if (s == nil || s.length == 0 || [s characterAtIndex:0] == '0') return 0;
    
    NSUInteger dp[s.length+1];
    memset(dp, 0, s.length+1);
    dp[0] = 1;	// empty string
    dp[1] = 1;	// string size 1 and first character is not '0'
    // i here means string size, not index
    for (NSInteger i=2; i<=s.length; i++) {
        unichar p = [s characterAtIndex:i-2];
        unichar c = [s characterAtIndex:i-1];
        if (c > '0') dp[i] = dp[i-1];
        if (p == '1' || (p == '2' && c <= '6')) dp[i] += dp[i-2];
    }
    return dp[s.length];
}

- (NSUInteger)numDecodingsConstantSpace:(NSString *)s {
    if (s == nil || s.length == 0 || [s characterAtIndex:0] == '0') return 0;
    // d1: decoding ways of d[i-1]
    // d2: decoding ways of d[i-2]
    NSUInteger d1 = 1, d2 = 1, res = 0;
    for (NSInteger i=2; i<=s.length; i++) {
        unichar p = [s characterAtIndex:i-2];
        unichar c = [s characterAtIndex:i-1];
        if (c != '0') res += d1;
        if (p == '1' || (p == '2' && c <= '6')) res += d2;
        // update d1 and d2
        d2 = d1; d1 = res; res = 0;
    }
    return res;
}

==============================================================================

Question 31: 骑士（国际象棋棋盘）
http://www.1point3acres.com/bbs/thread-192346-1-1.html

==============================================================================

Question 32: Longest Consecutive Sequence
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

For example,
Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.

Your algorithm should run in O(n) complexity.

// Ask interviewer: any duplicate? can not use sort for sure.
// http://www.jiuzhang.com/solutions/longest-consecutive-sequence/
// https://leetcode.com/problems/longest-consecutive-sequence/?tab=Solutions
// Idea: use hash table/set to hold numbers. when we see N in the set, we check ALL its upper
// and lower consecutive neighbors and remove then from the set.
// because we scale the size of set down, so the running time is about O(N)

- (NSUInteger)longestConsecutive:(NSArray<NSNumber *> *)nums {
	NSMutableSet<NSNumber *> *set = [NSMutableSet setWithArray:nums];
	NSUInteger longest = 0;
	for (NSInteger i=0; i<nums.count; i++) {
		NSNumber *down = @(nums[i].integerValue-1);
		while ([set containsObject:down]) {
			[set removeObject:down];
			down = @(down.integerValue-1);
		}
		
		NSNumber *up = @(nums[i].integerValue+1);
		while ([set containsObject:up]) {
			[set removeObject:up];
			up = @(up.integerValue+1);
		}
		longest = MAX(longest, up.integerValue - down.integerValue - 1);
	}
	return longest;
}

==============================================================================

Question 33: Construct BST from given preorder traversal

Given preorder traversal of a binary search tree, construct the BST.
For example, if the given traversal is {10, 5, 1, 7, 40, 50}, then the output should be root of following tree.

     10
   /    \
  5     40
 /  \     \
1    7     50

// for this question, first understan pre-order traversal.
// for pre-order traversal, the first element ALWAYS is root.
// Because this is a Binary search tree, then we can rebuild the tree. Otherwise we can not.
// Ask interviewer: integer values? scale of the tree? any duplicate?
// If we want a constant space solution, use pointers instead of left and right node arrays
// http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/
/* The trick is to write a utility helper function isBSTUtil(struct node* node, int min, int max) that traverses down the tree keeping track of the narrowing min and max allowed values as it goes, looking at each node only once. The initial values for min and max should be INT_MIN and INT_MAX — they narrow from there. */
// Stack solution here: http://www.geeksforgeeks.org/construct-bst-from-given-preorder-traversal-set-2/

// O(N^2)
- (Tree *)BSTFromPreOrderTraversal:(NSArray<NSNumber *> *)preorder {
    if (preorder == nil || preorder.count == 0) return nil;
    NSMutableArray *leftNodes = [NSMutableArray array];
    NSMutableArray *rightNodes = [NSMutableArray array];
    Tree *root = [Tree nodeWithValue:preorder[0].integerValue];
    for (NSInteger i=1; i<preorder.count; i++) {
        if (preorder[i].integerValue <= preorder[0].integerValue) {
            [leftNodes addObject:preorder[i]];
        } else {
            [rightNodes addObject:preorder[i]];
        }
    }
    root.left = [self BSTFromPreOrderTraversal:leftNodes];
    root.right = [self BSTFromPreOrderTraversal:rightNodes];
    return root;
}

// O(N)
- (Tree *)BSTFromPreOrderRecersive:(NSArray<NSNumber *> *)preorder {
    if (preorder == nil || preorder.count == 0) return nil;
    NSUInteger start = 0;
    return [self helper:preorder key:preorder[start] start:&start min:NSIntegerMin max:NSIntegerMax];
}

- (Tree *)helper:(NSArray<NSNumber *> *)preorder key:(NSNumber *)key start:(NSUInteger *)start
             min:(NSInteger)min max:(NSInteger)max {
    if (*start >= preorder.count) return nil;
    Tree *root = nil;
    if (key.integerValue > min && key.integerValue < max) {
        root = [Tree nodeWithValue:key.integerValue];
        (*start)++;
        if (*start < preorder.count) {
            root.left = [self helper:preorder key:preorder[*start] start:start min:min max:key.integerValue];
            root.right = [self helper:preorder key:preorder[*start] start:start min:key.integerValue max:max];
        }
    }
    return root;
}

- (Tree *)BSTFromPreorderStack:(NSInteger [])preorder size:(NSUInteger)size {
    if (preorder == nil || size == 0) return nil;
    
    NSMutableArray<Tree *> *stack = [NSMutableArray array];
    Tree *rootNode = [Tree nodeWithValue:preorder[0]];
    [stack addObject:rootNode];
    
    for (NSInteger i=1; i<size; i++) {
        if (preorder[i] < stack.lastObject.value) {
            // when the current value is less than peek value of stack
            // this means current value is left node if stack peek node
            Tree *root = stack.lastObject;
            Tree *left = [Tree nodeWithValue:preorder[i]];
            root.left = left;
            [stack addObject:left];
        } else {
            // otherwise, the current value will be a right node of previous nodes
            // pop nodes until we find the previous root
            // add current value as right node of previous root
            // then push current node
            Tree *root = nil;
            while (stack.count && preorder[i] > stack.lastObject.value) {
                root = stack.lastObject;
                [stack removeLastObject];
            }
            if (root) {
                Tree *right = [Tree nodeWithValue:preorder[i]];
                root.right = right;
                [stack addObject:right];
            }
        }
    }
    return rootNode;
}

==============================================================================

Question 33: Maximum Subarray

Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.

// Traditional Dynamic Programming Question
// Ask interviewer: nil handling? positive, negative?

- (NSInteger)maxSubArray(NSArray<NSNumber *> *)nums {
	if (!nums) return NSIntegerMin;
	NSInteger maxCur = NSIntegerMin;
	NSInteger maxSoFar = NSIntegerMin;
	for (NSInteger i=0; i<nums.count; i++) {
		maxCur = MAX(maxCur + nums[i].integerValue, nums[i].integerValue);
		maxSoFar = MAX(maxCur, maxSoFar);
	}
	return maxSoFar;
}

==============================================================================

Question 34: Subarray with sum equals to K

Whether there is a subarray's sum equals to k, here all numbers are non-negative numbers.

For example: [2, 3, 1, 2, 4, 5, 6], k = 10

http://www.1point3acres.com/bbs/thread-206502-1-1.html

// Because for this question, all numbers are positive numbers.
// So we can use Slide Window to find the answer

- (BOOL)subArrayInArray:(NSArray<NSNumber *> *)nums sum:(NSUInteger)k {
    if (nums == nil || nums.count == 0) return NO;
    NSInteger sum = 0;
    NSUInteger start = 0;
    for (NSInteger end = 0; end<nums.count; end++) {
        sum += nums[end].integerValue;
        if (sum == k) {
            return YES;
        }
        while (sum > k && start <= end) {
            sum -= nums[start++].integerValue;
        }
    }
    return NO;
}

==============================================================================

Question 35: Maximum Size Subarray Sum Equals k
 
Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.

Note:
The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.

Example 1:
Given nums = [1, -1, 5, -2, 3], k = 3,
return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)

// http://www.programcreek.com/2014/10/leetcode-maximum-size-subarray-sum-equals-k-java/
// https://discuss.leetcode.com/topic/33259/o-n-super-clean-9-line-java-solution-with-hashmap

- (NSUInteger)maximumSizeSubarrayInArray:(NSArray<NSNumber *> *)nums k:(NSInteger)k {
    NSMutableDictionary<NSNumber *, NSNumber *> *preSums = [NSMutableDictionary dictionary];
    NSUInteger maxSize = 0;
    NSInteger sum = 0;
    for (NSInteger i = 0; i<nums.count; i++) {
        sum += nums[i].integerValue;
        if (sum == k) maxSize = MAX(maxSize, i+1);
        if (preSums[@(sum-k)]) maxSize = MAX(maxSize, i-preSums[@(sum-k)].integerValue);
        if (!preSums[@(sum)]) preSums[@(sum)] = @(i);
    }
    return maxSize;
}

==============================================================================

Question 36: Submatrix with sum equals to K

Given a n×nn×n matrix A[0...m-1][0....n-1] where all entries are non-negative integers, and a non-negative integer K, find whether there is submatrix with sum to K

http://www.1point3acres.com/bbs/thread-206502-1-1.html
CC150 page 492

// Naive solution: O(M^2*N^2) -> O(N^4)
// - we make two outer for loops to traverse all nodes in the matrix left to right
// - then we use two inner for loops to traverse sub matrixes from current node left to right,
//   and calculate sum for each sub matrix. If sum equals to K, we return YES.
// Better solution: O(N^3)
// - We all know the solution of "Question 34: Subarray with sum equals to K", which works well for 1-dimension
//   array.
// - Now we have a two dimension matrix. So we need to think "how to downgrade it into 1-dimension question."
// - We calculate sum for each column from "start row" to "end row" column by column
// - Then we use "subarray with sum equals to K" solution for this "column sum array" between "start row" and 	  //   "end row"
// NOTICE: we MUST make sure that all matrix node should be non-negative numbers

- (BOOL)subMatrixOfMatrix:(NSArray<NSArray<NSNumber *> *> *)matrix k:(NSUInteger)k {
    if (matrix == nil) return NO;
    NSUInteger m = matrix.count;
    if (m == 0) return NO;
    NSUInteger n = matrix[0].count;
    NSMutableArray<NSNumber *> *partialSums = [NSMutableArray array];
    for (NSInteger rowStart=0; rowStart<m; rowStart++) {
        // remove all objects for each iteration
        [partialSums removeAllObjects];
        for (NSInteger rowEnd=rowStart; rowEnd<m; rowEnd++) {
            for (NSInteger col=0; col<n; col++) {
                partialSums[col] = @(partialSums[col].integerValue + matrix[rowEnd][col].integerValue);
            }
            BOOL found = [self subArrayInArray:partialSums sum:k];
            if (found) return YES;
        }
    }
    return NO;
}

- (BOOL)subArrayInArray:(NSArray<NSNumber *> *)nums sum:(NSUInteger)k {
    if (nums == nil || nums.count == 0) return NO;
    NSInteger sum = 0;
    NSUInteger start = 0;
    for (NSInteger end = 0; end<nums.count; end++) {
        sum += nums[end].integerValue;
        if (sum == k) {
            return YES;
        }
        while (sum > k && start <= end) {
            sum -= nums[start++].integerValue;
        }
    }
    return NO;
}

==============================================================================

Question 37: Implement strStr()

Implement strStr().

Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

// Basic solution: Brute Force, O(N*k), check from beginning to end-needle.count-1, 
// start comparing needle and haystack at index i when haystack[i] == needle[i]
// KMP solution: http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/
// https://leetcode.com/problems/implement-strstr/?tab=Solutions
// Ask interviewer: handle nil?

- (NSUInteger)strStr:(NSString *)haystack needle:(NSString *)needle {
    if (haystack == nil || needle == nil) return -1;
    for (NSInteger i=0; i<haystack.length-needle.length; i++) {
        NSInteger j=0;
        for (; j<needle.length; j++) {
            if ([haystack characterAtIndex:i+j] != [needle characterAtIndex:j]) break;
        }
        if (j == needle.length) return i;
    }
    return -1;
}

==============================================================================

Question 38: Implement strStr() II

TODO: find this question

==============================================================================

Question 39: Read N Characters Given Read4

The API: int read4(char *buf) reads 4 characters at a time from a file.
The return value is the actual number of characters read. 
For example, it returns 3 if there is only 3 characters left in the file.
By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.
Note: The read function will only be called once for each test case.

http://bangbingsyb.blogspot.fi/2014/11/leetcode-read-n-characters-given-read4.html
http://www.jiuzhang.com/solutions/read-n-characters-given-read4/

NSUInteger read4(char *buf);

@implementation Read4

- (NSUInteger)read:(char *)buf n:(NSUInteger)n {
    char buf4[4];
    NSUInteger size = 0;
    while (true) {
        NSUInteger actual = read4(buf4);
        for (NSUInteger i=0; i<actual && size < n; i++) {
            buf[size++] = buf4[i];
        }
        if (actual == 0 || size == n) return size;
    }
}

==============================================================================

Question 40: Merge K Sorted Arrays/Linked Lists

Merge k sorted Arrays/Linked Lists and return it as one sorted Array/List

http://www.programcreek.com/2014/05/merge-k-sorted-arrays-in-java/

// Priority Queue question.
// Also can be done by Binary Search Tree in my opinion

==============================================================================

Question 41: Minimum Depth of Binary Tree

Given a binary tree, find its minimum depth.
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

Follow up: How about is the left/right tree is much deeper than right/left tree?

// Basic solution: Traditional DFS question. Also similar to "Maximum Depth of Binary Tree" question.
// Ask interviewer: binary tree balanced? size of the tree? depth of nil, 0 or 1?
// NOTICE: be careful of special cases: all left nodes, or all right nodes

- (NSUInteger)minDepthDFS:(Tree *)root {
    if (root == nil) return 0;
    if (!root.left) return [self minDepthDFS:root.right]+1;
    if (!root.right) return [self minDepthDFS:root.left]+1;
    return MIN([self minDepthDFS:root.left], [self minDepthDFS:root.right])+1;
}

// Idea: return when first time meeting a "leaf node"
- (NSUInteger)minDepthBFS:(Tree *)root {
    if (root == nil) return 0;
    NSUInteger depth = 0;
    NSMutableArray<Tree *> *queue = [NSMutableArray array];
    [queue addObject:root];
    while (queue.count) {
        depth += 1;
        NSUInteger size = queue.count;
        NSMutableArray<Tree *> *newNodes = [NSMutableArray array];
        for (NSInteger i=0; i<size; i++) {
            Tree *node = queue[i];
            if (node.left == nil && node.right == nil) return depth;
            if (node.left) [newNodes addObject:node.left];
            if (node.right) [newNodes addObject:node.right];
        }
        [queue removeAllObjects];
        [queue addObjectsFromArray:newNodes];
    }
    return depth;
}

==============================================================================

Question 42: Best Time to Buy and Sell Stock

Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Example 1:
Input: [7, 1, 5, 3, 6, 4]
Output: 5

max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
Example 2:
Input: [7, 6, 4, 3, 1]
Output: 0

In this case, no transaction is done, i.e. max profit = 0.

// Idea: keep tracking the minimum price of the stock. Then sell on highest price after it.
// Ask interviewer: prices are positive or negative or both? All integers? handling 0 count or 1 count

- (NSInteger)maxProfit:(NSArray<NSNumber *> *)prices {
	if (prices == nil || prices.count == 0) return NSIntegerMin;
	NSInteger maxProfit = NSIntegerMin;
	NSInteger minPrice = NSIntegerMax;
	for (NSInteger i=0; i<prices.count; i++) {
		NSInteger price = prices[i].integerValue;
		minPrice = MIN(price, minPrice);
		maxProfit = MAX(maxProfit, price-minPrice);
	}
	return maxProfit;
}

==============================================================================

Question 43: Binary Tree Paths

Given a binary tree, return all root-to-leaf paths.
For example, given the following binary tree:

   1
 /   \
2     3
 \
  5
  
All root-to-leaf paths are:

["1->2->5", "1->3"]

// DFS, BFS
// Ask interviewer: what to return nil root?

- (NSArray<NSString *> *)binaryTreePaths:(Tree *)root {
    if (root == nil) return nil;
    NSMutableArray<NSString *> *path = [NSMutableArray array];
    NSMutableArray<NSString *> *results = [NSMutableArray array];
    [self dfs:root path:path results:results];
    return [results copy];
}

- (void)dfs:(Tree *)root path:(NSMutableArray<NSString *> *)path
    results:(NSMutableArray<NSString *> *)results {
    if (root == nil) return;
    if (root.left == nil && root.right == nil) {
        [path addObject:@(root.value).stringValue];
        [results addObject:[path componentsJoinedByString:@"->"]];
        [path removeLastObject];
        return ;
    }
    
    [path addObject:@(root.value).stringValue];
    [self dfs:root.left path:path results:results];
    [self dfs:root.left path:path results:results];
    [path removeLastObject];
}

- (NSArray<NSString *> *)binaryTreePathsShort:(Tree *)root {
    NSMutableArray<NSString *> *paths = [NSMutableArray array];
    if (root == nil) return paths;
    if (root.left == nil && root.right == nil) {
        [paths addObject:@(root.value).stringValue];
        return paths;
    }
    
    for (NSString *path in [self binaryTreePathsShort:root.left]) {
        [paths addObject:[NSString stringWithFormat:@"%@->%@", @(root.value).stringValue, path]];
    }
    
    for (NSString *path in [self binaryTreePathsShort:root.right]) {
        [paths addObject:[NSString stringWithFormat:@"%@->%@", @(root.value).stringValue, path]];
    }
    return paths;
}

==============================================================================

Question 44: Contains Duplicate III

Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.

// When we see "at most" keywords, one thing we can guess is Slide Window
// Ask interviewer: is the array sorted or not? any duplicate?
// For this question, there are "Heap" solution and "Bucket" solution
// For objective-c, "binary search" solution is more straight forward.
// NSOrderedSet is a great class for handling order of hashed unique objects
// Idea: https://leetcode.com/problems/contains-duplicate-iii/?tab=Solutions
// - keep a "Window set" which tracking at most k recent numbers
// - insert each number into window set by binary search, in order to keep the set sorted
// - we know that "|x - nums[i]| <= t" means "-t <= x - nums[i] <= t"
// - we first find x from window set, which "x - nums[i] >= -t" ==> "x >= nums[i]-t"
// - then we confirm that "there is such x in windows set" and also "x - nums[i] <= t"
// - if so, we return YES. Otherwise we insert nums[i] into window set, and loop.
// - if loop completes, we return NO

- (BOOL)containsNearbyAlmostDuplicate:(NSArray<NSNumber *> *)nums k:(NSInteger)k t:(NSInteger)t {
    NSMutableOrderedSet<NSNumber *> *window = [NSMutableOrderedSet orderedSet];
    for (NSInteger i=0; i<nums.count; i++) {
        // i == k -> k-1 elements
        if (i>k) [window removeObjectAtIndex:i-k-1];
        NSInteger num = nums[i].integerValue;
        // find the insertion index of num-t
        NSUInteger pos = [window indexOfObject:@(num - t)
                                 inSortedRange:NSMakeRange(0,window.count)
                                       options:NSBinarySearchingInsertionIndex
                               usingComparator:^NSComparisonResult(NSNumber *num1, NSNumber *num2) {
                                   return [num1 compare:num2];
                               }];
        // if there are numbers larger than num - t, also that number is smaller or equal than num+t
        // then we find the result, and return
        if ((pos != window.count-1) && (window[pos].integerValue - num <= t)) return YES;
        // if not found any result, then we insert the number into the sorted ordered set
        // in this way, we can always keep the window set sorted
        pos = [window indexOfObject:@(num)
                      inSortedRange:NSMakeRange(0,window.count)
                            options:NSBinarySearchingInsertionIndex
                    usingComparator:^NSComparisonResult(NSNumber *num1, NSNumber *num2) {
                        return [num1 compare:num2];
                    }];
        [window insertObject:@(num) atIndex:pos];
    }
    return NO;
}

==============================================================================

Question 45: Check Duplicate Numbers In Window k
http://www.geeksforgeeks.org/check-given-array-contains-duplicate-elements-within-k-distance/

Given an unsorted array that may contain duplicates. Also given a number k which is smaller than size of array. Write a function that returns true if array contains duplicates within k distance.

Examples:

Input: k = 3, arr[] = {1, 2, 3, 4, 1, 2, 3, 4}
Output: false
All duplicates are more than k distance away.

Input: k = 3, arr[] = {1, 2, 3, 1, 4, 5}
Output: true
1 is repeated at distance 3.

Input: k = 3, arr[] = {1, 2, 3, 4, 5}
Output: false

Input: k = 3, arr[] = {1, 2, 3, 4, 4}
Output: true

// Similar question to "Question 43: Contains Duplicate III"
// we can use a window set to keep tracking number we met at most k element before
// Ask interviewer: is k valid? nil handling?

- (BOOL)checkDuplicatesWithinK:(NSArray<NSNumber *> *)nums k:(NSUInteger)k {
    NSMutableOrderedSet<NSNumber *> *window = [NSMutableOrderedSet orderedSet];
    for (NSInteger i=0; i<nums.count; i++) {
        if (i > k) [window removeObjectAtIndex:i-k-1];
        NSNumber *num = nums[i];
        if ([window containsObject:num]) return YES;
        [window addObject:num];
    }
    return NO;
}

==============================================================================

Question 46: Find All Anagrams in a String

Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.
Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.
The order of output does not matter.

Example 1:

Input:
s: "cbaebabacd" p: "abc"

Output:
[0, 6]

Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".
Example 2:

Input:
s: "abab" p: "ab"

Output:
[0, 1, 2]

Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".

// When we meet anagram, we can think of using hash table + counter to reach O(N) time complexity
// Ask interviewer: what kind of character containing in the string? all letters?
// is the input always valid? how about nil? s.length > p.length?
// Naive solution: hash table + counter + Brute Force
// Better solution: hash table + counter + Slide Window

- (NSArray<NSNumber *> *)findAnagrams:(NSString *)s p:(NSString *)p {
	NSMutableDictionary<NSString *, NSNumber *> *hashTable = [NSMutableDictionary dictionary];
	NSMutableArray<NSNumber *> *results = [NSMutableArray array];
	
	// put all letters in p into hash table, count them
	for (NSInteger i=0; i<p.length; i++) {
		NSString *c = [p substringInRange:NSMakeRange(i,1)];
		if (!hashTable[c]) hashTable[c] = @(1);
		else hashTable[c] = @(hashTable[c].integerValue+1);
	}
	
	// now we iterate s from beginning to end
	NSInteger count = p.length;
	NSInteger start = 0, end = 0;
	while (end < s.length) {
		NSString *c = [s substringInRange:NSMakeRange(i,1)];
		
		// if current character is not in p, we still add them into hash table
		if (!hashTable[c]) hashTable[c] = @(0);
		
		// decrease the total count and letter count by 1
		if (hashTable[c].integerValue > 0) count--;
		
		hashTable[c] = @(hashTable[c].integerValue-1);
		// move the end pointer to next one
		end++;
		
		// if count == 0, then we find a anagram of p.
		if (count == 0) [results addObject:@(start)];
		
		if (end - start == p.length) {
			NSString *sc = [p substringInRange:NSMakeRange(start, 1)];
			// here we filter out all non-anagram letters, whose count is -1.
			if (hashTable[sc].integerValue >= 0) count++;
			hashTable[sc] = @(hashTable[sc].integerValue+1);
			start++;
		}
	}
	// http://stackoverflow.com/questions/27389591/best-practice-return-mutablearray-copy-or-mutablearray-if-return-type-is-nsarra
	/* Generally speaking:
	   If your caller is following these guidelines, just return the mutable array since it's slightly cheaper, 	   and the caller won't mutate it.
       If you're not sure whether caller might not follow these guidelines, and you want to code defensively, 	   return an immutable copy using array.copy.
	**/
	return [results copy];
}

==============================================================================

Question 47: First Bad Version

You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

// Traditional binary search question.
// NOTICE: be careful about upper_bound or lower_lound. 

BOOL isBadVersion(NSUInteger version);

- (NSUInteger)firstBadVersion:(NSUInteger)n {
    NSInteger left = 1;
    NSInteger right = n;
    while(left < right) {
        NSInteger mid = left + (right-left)/2;
        if (!isBadVersion(mid)) left = mid+1;
        else right = mid;
    }
    return left;
}

==============================================================================

Question 47: Valid Palindrome

Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

For example,
"A man, a plan, a canal: Panama" is a palindrome.
"race a car" is not a palindrome.

Note:
Have you consider that the string might be empty? This is a good question to ask during an interview.

For the purpose of this problem, we define empty string as valid palindrome.

// Traditional double pointer question.
// be careful about "whitespaces"
// use NSCharacterSet to check if current character is alphanumeric

- (BOOL)isPalindrome:(NSString *)s {
    NSInteger left = 0, right = s.length-1;
    NSCharacterSet *alphanumeric = [NSCharacterSet alphanumericCharacterSet];
    while (left < right) {
        while (left < right && ![alphanumeric characterIsMember:[s characterAtIndex:left]]) left++;
        while (left < right && ![alphanumeric characterIsMember:[s characterAtIndex:right]]) right--;
        unichar lc = [s characterAtIndex:left];
        unichar lr = [s characterAtIndex:right];
        if (lc != lr) return NO;
        left++; right--;
    }
    return YES;
}

==============================================================================

Question 48: Dot Product Of Sparse Vector

Given two sparse Vectors, compute the Dot Product. 

For example: [1, 3, 2, 3, 4, 3, 4] and [0, 0, 0, 2, 0, 1, 0, 0]

http://www.1point3acres.com/bbs/thread-117371-1-1.html
https://discuss.leetcode.com/topic/199/dot-product-of-sparse-vector/2
https://www.careercup.com/question?id=5678837729853440

Similar Question: Sparse Matrix multiplication
// Solutions:
// http://www.jiuzhang.com/solutions/sparse-matrix-multiplication/
// http://buttercola.blogspot.fi/2016/01/leetcode-sparse-matrix-multiplication.html

// Actually Vector is 1 dimension Matrix.
// When we see "Sparse Matrix", which contains many '0's, 
// we could use Hash Table/Adjacent List to save memory space, also increase algorithm efficiency.
// Also if we do it without extra memory, we should check '0's in the more sparse matrix,
// and skip them during calculation.


==============================================================================

Question 49: Sparse Matrix Multiplication

Given two sparse matrices A and B, return the result of AB.
You may assume that A's column number is equal to B's row number.

Example:
A = [
  [ 1, 0, 0],
  [-1, 0, 3]
]

B = [
  [ 7, 0, 0 ],
  [ 0, 0, 0 ],
  [ 0, 0, 1 ]
]


     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |
AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |
                  | 0 0 1 |
				  
// Similar with Question 48

==============================================================================

Question 50: Longest Increasing(Arithmetic) Subsequence I

Given an unsorted array of integers, find the length of longest increasing subsequence.

For example,
Given [10, 9, 2, 5, 3, 7, 101, 18],
The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.

Your algorithm should run in O(n^2) complexity.

Follow up: Could you improve it to O(n log n) time complexity?

// "Longest" incidates the possibility of using "Dynamic Programming"
// Ask interviewer: positive, negative? sorted? size? duplicates?
// Naive Solution: two for loop to check from beginning to the end
// Better solution: dynamic programming. But even with dynamic programming, time complexity is still O(N^2)
// we need binary search to decrease it to O(NLog(N))
// in order to use binary search, we MUST have a sorted array.
// http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/
// NOTICE:
// - The result is NOT the real result. 
// - Only the "Length Of The Result" is the same as the length of final result.
// http://www.jiuzhang.com/solutions/longest-increasing-subsequence/
// http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/

- (NSUInteger)lengthOfLISDP:(NSArray<NSNumber *> *)nums {
    if (!nums || nums.count == 0) return 0;
    NSUInteger dp[nums.count];
    NSUInteger max = 0;
    for (NSInteger i=1; i<nums.count; i++) {
        dp[i] = 1;
        for (NSInteger j=i-1; j>=0; j++) {
            NSInteger num = nums[i].integerValue;
            if (num > dp[j]) dp[i] = MAX(dp[j]+1, dp[i]);
        }
        if (dp[i] > max) max = dp[i];
    }
    return max;
}

/*Our strategy determined by the following conditions,
 
 1. If A[i] is smallest among all end
 candidates of active lists, we will start
 new active list of length 1, but still keep rest in the array,
 which stands for the current maximum value
 2. If A[i] is largest among all end candidates of
 active lists, we will clone the largest active
 list, and extend it by A[i].
 
 3. If A[i] is in between, we will find a list with
 largest end element that is smaller than A[i].
 Clone and extend this list by A[i]. We will discard all
 other lists of same length as that of this modified list.*/

- (NSUInteger)lengthOfLISBinarySearch:(NSArray<NSNumber *> *)nums {
    NSMutableArray<NSNumber *> *fakeResults = [NSMutableArray array];
    for (NSInteger i=0; i<nums.count; i++) {
        NSNumber *num = nums[i];
        // find insertion index
        NSUInteger idx = [fakeResults indexOfObject:num inSortedRange:NSMakeRange(0,fakeResults.count)
                                            options:NSBinarySearchingInsertionIndex
                                         usingComparator:^NSComparisonResult(NSNumber *num1, NSNumber *num2) {
                                             return [num1 compare:num2];
                                         }];
        if (idx == fakeResults.count) [fakeResults addObject:num];
        else fakeResults[i] = num;
    }
    // The result is NOT the real result.
    // Only the "Length Of The Result" is the same as the length of final result.
    return fakeResults.count;
}

==============================================================================

Question 51: Binary Tree Longest Consecutive Sequence
 
Given a binary tree, find the length of the longest consecutive sequence path.

The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse).

For example,

   1
    \
     3
    / \
   2   4
        \
         5
		 
Longest consecutive sequence path is 3-4-5, so return 3.

   2
    \
     3
    / 
   2    
  / 
 1
 
Longest consecutive sequence path is 2-3,not3-2-1, so return 2.

// Ask interviewer: BST? numbers are all positive? duplicates?
// http://www.cnblogs.com/grandyang/p/5252599.html (My solution is actually the divide&conquer one! \o/)
// http://www.jiuzhang.com/solutions/binary-tree-longest-consecutive-sequence/

- (NSUInteger)longestConsecutive:(Tree *)root {
    return [self helper:root parent:nil lengthWithoutRoot:0];
}

- (NSUInteger)helper:(Tree *)root parent:(Tree *)parent lengthWithoutRoot:(NSUInteger)lengthWithoutRoot {
    if (root == nil) return 0;
    NSUInteger length = (parent != nil && root.value == parent.value+1) ? lengthWithoutRoot+1 : 1;
    NSUInteger left = [self helper:root.left parent:root lengthWithoutRoot:length];
    NSUInteger right = [self helper:root.right parent:root lengthWithoutRoot:length];
    return MAX(length, MAX(left, right));
}

==============================================================================

Question 52: Word Search

Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

For example,
Given board =

[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "ABCCED", -> returns true,
word = "SEE", -> returns true,
word = "ABCB", -> returns false.

// Ask interviewer: capital letter? all inputs valid?
// Traditional DFS + Backtracking solution O(M*N*4*k) = O(kN^2)
// NOTICE: we can decrease space consumption by mark visited node in the board
// for example, mark it into '#' and change it back after tracking back.
// https://leetcode.com/problems/word-search/?tab=Solutions
// http://www.jiuzhang.com/solutions/word-search/

- (BOOL)exist:(NSArray<NSArray<NSString *> *> *)board word:(NSString *)word {
    if (board == nil || word == nil || word.length == 0) return NO;
    NSUInteger m = board.count;
    if (m == 0) return NO;
    NSUInteger n = board[0].count;
    NSString *firstC = [word substringWithRange:NSMakeRange(0,1)];
    for (NSInteger i=0; i<m; i++) {
        for (NSInteger j=0; j<n; j++) {
            NSString *c = board[i][j];
            NSMutableSet<NSValue *> *visited = [NSMutableSet set];
            if ([c isEqualToString:firstC]) {
                BOOL found = [self dfs:board i:i j:j word:word start:0 visited:visited];
                if (found) return YES;
            }
        }
    }
    return NO;
}

- (BOOL)dfs:(NSArray<NSArray<NSString *> *> *)board
          i:(NSInteger)i j:(NSInteger)j
       word:(NSString *)word
      start:(NSUInteger)start
    visited:(NSMutableSet<NSValue *> *)visited {
    if (start == word.length) return YES;
    if (i>board.count-1 || i<0 || j>board[0].count-1 || j<0) return NO;
    // for iOS, use valueWithCGPoint and NSMakeCGPoint
    NSValue *pos = [NSValue valueWithPoint:NSMakePoint(i, j)];
    if ([visited containsObject:pos]) return NO;
    [visited addObject:pos];
    
    NSString *bc = board[i][j];
    NSString *sc = [word substringWithRange:NSMakeRange(start,1)];
    if (![bc isEqualToString:sc]) return NO;
    // go left, right, up and down
    return [self dfs:board i:i+1 j:j word:word start:start+1 visited:visited] ||
    [self dfs:board i:i-1 j:j word:word start:start+1 visited:visited] ||
    [self dfs:board i:i j:j+1 word:word start:start+1 visited:visited] ||
    [self dfs:board i:i j:j-1 word:word start:start+1 visited:visited];
}

==============================================================================

Question 52: Word Search II

Given a 2D board and a list of words from the dictionary, find all words in the board.

Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

For example,
Given words = ["oath","pea","eat","rain"] and board =

[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
Return ["eat","oath"].

Note: You may assume that all inputs are consist of lowercase letters a-z.

// If we use solution in Question 51, and search word by word, 
// then the time complexity will be extremely high.
// for string searching, we can use Trie to compress and store the whole dictionary words
// the searching time for a word will drop to O(M), where M is the average length of words.
// So Trie + Backtracking is a good solution.
// NOTICE: we DON'T implement Trie structure here.
// http://www.jiuzhang.com/solutions/word-search-ii/

- (NSArray<NSString *> *)findWords:(NSArray<NSString *> *)words
                           inBoard:(NSArray<NSArray<NSString *> *> *)board {
    if (board == nil || words == nil || words.count == 0) return NO;
    NSUInteger m = board.count;
    if (m == 0) return NO;
    NSUInteger n = board[0].count;
    
    // first, we create the Trie
    Trie *trie = [Trie trie];
    for (NSInteger i=0; i<words.count; i++) {
        [trie addWord:words[i]];
    }
    
    // we use set here to avoid duplicates
    NSMutableSet<NSString *> *results = [NSMutableSet set];
    // then, we still do dfs
    for (NSInteger i=0; i<m; i++) {
        for (NSInteger j=0; j<n; j++) {
            NSMutableSet<NSValue *> *visited = [NSMutableSet set];
            [self dfs:board i:i j:j word:board[i][j] trieNode:trie.root
              visited:visited results:results];
        }
    }
    return [results allObjects];
}

- (void)dfs:(NSArray<NSArray<NSString *> *> *)board
          i:(NSInteger)i j:(NSInteger)j
       word:(NSString *)word
   trieNode:(TrieNode *)trieNode
    visited:(NSMutableSet<NSValue *> *)visited
    results:(NSMutableSet<NSString *> *)results {
    if (i>board.count-1 || i<0 || j>board[0].count-1 || j<0) return;
    // for iOS, use valueWithCGPoint and NSMakeCGPoint
    NSValue *pos = [NSValue valueWithPoint:NSMakePoint(i, j)];
    if ([visited containsObject:pos]) return;
    [visited addObject:pos];
    
    unichar c = [board[i][j] characterAtIndex:0];
    if (![trieNode hasChild:c]) return;
    NSString *nextWord = [word stringByAppendingString:board[i][j]];
    TrieNode *nextNode = [trieNode getChild:c];
    if (nextNode.isWord) [results addObject:nextWord];
    
    [self dfs:board i:i+1 j:j word:nextWord trieNode:nextNode visited:visited results:results];
    [self dfs:board i:i-1 j:j word:nextWord trieNode:nextNode visited:visited results:results];
    [self dfs:board i:i j:j+1 word:nextWord trieNode:nextNode visited:visited results:results];
    [self dfs:board i:i j:j-1 word:nextWord trieNode:nextNode visited:visited results:results];
}


