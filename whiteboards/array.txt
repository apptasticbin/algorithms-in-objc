Question 135: Permutations

https://leetcode.com/problems/permutations/#/description

==============================================================================

Question 2: [DONE]

Give you a array of digits, only swap it once, in order to maximum the number
that can be combined by these digits.

NOTICE: digits here are 0 to 9

For example, [4, 2, 1, 3, 5] is 42135, maximum number after one swap is 52134

// Ask interviewer: are these numbers unique or have duplicates
// Idea: sort the array first in decsend order; then compare digits one by one;
// when find the first digit not same, then find the "last" index of the digit, then swap
- (NSInteger)maximumNumberAfterOneSwap:(NSArray<NSNumber *> *)numbers {
    // sort number in descending order
    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:nil
                                                                     ascending:NO
                                                                      selector:@selector(compare:)];
    NSArray *sortedNumbers = [numbers sortedArrayUsingDescriptors:@[sortDescriptor]];
    
    // find the first number not same
    __block NSUInteger index = numbers.count;
    [numbers enumerateObjectsUsingBlock:^(NSNumber *num, NSUInteger idx, BOOL *stop) {
        if (num != sortedNumbers[idx]) {
            *stop = YES;
            index = idx;
        }
    }];
    
    __block NSUInteger swapIndex = numbers.count;
    NSNumber *destinationNumber = sortedNumbers[index];
    
    if (index != numbers.count) {
        [numbers enumerateObjectsWithOptions:NSEnumerationReverse
                                  usingBlock:^(NSNumber *num, NSUInteger idx, BOOL *stop) {
                                      if ([num isEqualToNumber:destinationNumber]) {
                                          swapIndex = idx;
                                          *stop = YES;
                                      }
                                  }];
    }
    NSMutableArray *mutableNumbers = [numbers mutableCopy];
    [mutableNumbers exchangeObjectAtIndex:index withObjectAtIndex:swapIndex];
    // combine numbers into a string
    NSString *maximumNumberStr = [mutableNumbers componentsJoinedByString:@""];
    return maximumNumberStr.integerValue;
}


==============================================================================

Question 8: K Cloest Points [DONE]

Given an array containing N points find the K closest points to the origin in the 2D plane. You can assume K is much smaller than N and N is very large.

// Traditional Quick Select question 
// https://en.wikipedia.org/wiki/Quickselect
// http://www.knowstack.com/sorting-algorithms-in-objective-c/
// Quick Select O(N), worse O(N^2)

/*
Quickselect uses the same overall approach as quicksort, choosing one element as a pivot and partitioning the data in two based on the pivot, accordingly as less than or greater than the pivot. However, instead of recursing into both sides, as in quicksort, quickselect only recurses into one side – the side with the element it is searching for. This reduces the average complexity from O(n log n) to O(n), with a worst case of O(n^2).
*/
// Ask Interviewer: point format? how about k = 0? how about k > points.count? how to select pivot, random or last // one?

- (NSArray<NSValue *> *)kCloestPoints:(NSUInteger)k fromPoints:(NSMutableArray<NSValue *> *)points {
    if (!points || !points.count || points.count < k) return nil;
    return [self kCloestPoints:k fromPoints:points start:0 end:points.count-1];
}

- (NSArray<NSValue *> *)kCloestPoints:(NSUInteger)k fromPoints:(NSMutableArray<NSValue *> *)points
                                start:(NSUInteger)start end:(NSUInteger)end {
	if (start >= end) return [points copy];
    // http://stackoverflow.com/questions/35758588/maximum-return-value-of-arc4random
    NSUInteger selectedPivot = start + arc4random_uniform(end-start+1);
    NSUInteger pivotIndex = [self partition:points start:start end:end pivot:selectedPivot];
    if (pivotIndex == k) return [points subarrayWithRange:NSMakeRange(0, k)];
    if (pivotIndex > k) return [self kCloestPoints:k fromPoints:points
                                             start:start end:pivotIndex-1];
    else return [self kCloestPoints:k fromPoints:points
                              start:pivotIndex+1 end:end];
}

- (NSUInteger)partition:(NSMutableArray<NSValue *> *)points
                  start:(NSUInteger)start end:(NSUInteger)end
                  pivot:(NSUInteger)pivot {
    // choose last one as the pivot value
    NSUInteger pivotIndex = start;
    NSUInteger pivotDistance = [self distanceToOriginFromPoint:points[pivotIndex].pointValue];
    // move pivot value to end
    [points exchangeObjectAtIndex:pivotIndex withObjectAtIndex:end];
    for (NSUInteger i=start; i<end; i++) {
        // NOTICE: we should use CGPointValue for iOS
        NSUInteger distance = [self distanceToOriginFromPoint:points[i].pointValue];
        if (distance < pivotDistance) {
            [points exchangeObjectAtIndex:pivotIndex withObjectAtIndex:i];
            pivotIndex++;
        }
    }
    [points exchangeObjectAtIndex:pivotIndex withObjectAtIndex:end];
    return pivotIndex;
}

- (NSUInteger)distanceToOriginFromPoint:(CGPoint)point {
    return point.x*point.x + point.y*point.y;
}

==============================================================================

Question 11: Sort Colors I [DONE]

https://leetcode.com/problems/sort-colors/?tab=Solutions

Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Note:
You are not suppose to use the library's sort function for this problem.

// we can write quick sort. 
// Two Pass Solution: counting sort
- (void)twoPassSortColors:(NSMutableArray<NSNumber *> *)colors {
    NSUInteger counter[3];
    for (NSUInteger i=0; i<colors.count; i++) {
        counter[colors[i].unsignedIntegerValue]++;
    }
    for (NSUInteger i=0, j=0; i<colors.count && j<3; i++) {
        if (counter[j] > 0) {
            colors[i] = @(j);
            counter[j]--;
        } else {
            j++;
        }
    }
}

// One Pass In-Place Solution: three pointer, similar to move zeros, but with three pointers
// 0 2 1 2 0 2 1 2
- (void)onePassSortColors:(NSMutableArray<NSNumber *> *)colors {
    NSUInteger zero = 0, one = 0, two = colors.count-1;
    for (; one <= two; one++) {
        if ([colors[one] isEqualToNumber:@(0)]) {
            [colors exchangeObjectAtIndex:zero withObjectAtIndex:one];
            zero++;
        } else if ([colors[one] isEqualToNumber:@(2)]) {
            [colors exchangeObjectAtIndex:two withObjectAtIndex:one];
            // NOTICE: when color is 2, then go back one index. the index will come back in next loop and stay here
            one--;
            two--;
        }
    }
}

// One Pass Tricky In-Place Solution
- (void)onePassTrickySortColors:(NSMutableArray<NSNumber *> *)colors {
    NSInteger zero = -1, one = -1, two = -1;
    for (NSUInteger i=0; i<colors.count; i++) {
        if ([colors[i] isEqualToNumber:@(0)]) {
            colors[++two] = @(2); colors[++one] = @(1); colors[++zero] = @(0);
        } else if ([colors[i] isEqualToNumber:@(1)]) {
            colors[++two] = @(2); colors[++one] = @(1);
        } else if ([colors[i] isEqualToNumber:@(2)]) {
            colors[++two] = @(2);
        }
    }
}

==============================================================================

Question 12: Sort Colors II [DONE]

Given an array of n objects with k different colors (numbered from 1 to k), sort them so that objects of the same color are adjacent, with the colors in the order 1, 2, ... k.

Notice: You are not suppose to use the library's sort function for this problem.

// Best solution, O(NLog(k))
- (void)sortColors2:(NSMutableArray<NSNumber *> *)colors k:(NSUInteger)k {
	// key idea: binary search
	if (!colors) return;
	[self rainbowSort:colors start:0 end:colors.count-1 colorFrom:1 colorTo:k];
}

// similar to quick sort "partition" method, pivot value is (colorTo+colorFram)/2
- (void)rainbowSort:(NSMutableArray<NSNumber *> *)colors
			  start:(NSUInteger)start end:(NSUInteger)end 
		  colorFrom:(NSUInteger)colorFrom colorTo:(NSUInteger)colorTo {
	if (start >= end) return;
	if (colorFrom == colorTo) return;
	// find the middle value
	NSUInteger colorMid = colorFrom + (colorTo-colorFrom)/2;
	NSUInteger s=start, e=end;
	while (s <= e) {
		while (s<=e && colors[s].unsignedIntegerValue <= colorMid) s++;
		while (s<=e && colors[e].unsignedIntegerValue > colorMid) e--;
		if (s <= e) {
			[colors exchangeObjectAtIndex:s withObjectAtIndex:e];
			s++;
			e--;
		}
	}
	[self rainbowSort:colors start:start end:e colorFrom:colorFrom colorTo:colorMid];
	[self rainbowSort:colors start:s end:end colorFrom:colorMid+1 colorTo:colorTo];
}

==============================================================================

Question 14: Number Of Islands [DONE]

Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example 1:

11110
11010
11000
00000
Answer: 1

Example 2:

11000
11000
00100
00011
Answer: 3

// Very tradiional DFS question.
// find '1's, each time we find unvisited '1', do DFS to mark all neighbour '1's as visited, and count++
// http://www.jiuzhang.com/solutions/number-of-islands/
-(NSUInteger)dfsNumIslands:(NSArray<NSArray<NSNumber *> *> *)grid {
    NSUInteger m = grid.count;
    if (m == 0) return 0;
    NSUInteger n = grid[0].count;
    NSUInteger count = 0;
    NSMutableSet<NSValue *> *visited = [NSMutableSet set];
    for (NSUInteger i=0; i<m; i++) {
        for (NSUInteger j=0; j<n; j++) {
            // NOTICE: should be valueWithCGPoint in iOS
            NSValue *pos = [NSValue valueWithPoint:CGPointMake(i, j)];
            if ([grid[x][y] isEqualToNumber:@(1)] &&
				![visited containsObject:pos]) {
                count++;
                [self DFS:grid i:i j:j m:m n:n visited:visited];
            }
        }
    }
    return count;
}

// https://www.tutorialspoint.com/objective_c/objective_c_passing_arrays_to_functions.htm
-(void)DFS:(NSArray<NSArray<NSNumber *> *> *)grid i:(NSInteger)i j:(NSInteger)j
         m:(NSUInteger)m n:(NSUInteger)n visited:(NSMutableSet<NSValue *> *) visited {
    if (i<0 || i>m-1 || j<0 || j>n-1) return;
    if ([grid[i][j] isEqualToNumber:@(0)]) return;
    // check if this land has been visited or not
    // NOTICE: should be valueWithCGPoint in iOS
    NSValue *pos = [NSValue valueWithPoint:CGPointMake(i, j)];
    if ([visited containsObject:pos]) return;
    // if not visited yet, mark it as visited
    [visited addObject:pos];
    // now go deeper to it's neighbors: up, down, left, right
    [self DFS:grid i:i+1 j:j m:m n:m visited:visited];
    [self DFS:grid i:i j:j+1 m:m n:m visited:visited];
    [self DFS:grid i:i-1 j:j m:m n:m visited:visited];
    [self DFS:grid i:i j:j-1 m:m n:m visited:visited];
}

==============================================================================

Question 15: Find Minimum in Rotated Sorted Array I && II [DONE]

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).Find the minimum element.

NOTICE: You may assume no duplicate exists in the array.
FOLLOW UP: What if duplicates are allowed? Would this affect the run-time complexity? How and why?

// Traditional binary search question
// Ask interviewer: duplicates? all positive? how about nil pointer handling?
// Check two element case [2, 1] and [1, 2]
// https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/?tab=Solutions
- (NSNumber *)findMin:(NSArray<NSNumber *> *)nums {
    NSParameterAssert(nums);	// prevent nums to be nil
    NSUInteger left = 0, right = nums.count-1;
    while (left < right) {
        NSUInteger mid = left + (right-left) / 2;
        if ([nums[mid] compare:nums[right]] == NSOrderedDescending ||
            [nums[mid] compare:nums[right]] == NSOrderedSame) {
            left = mid+1;
        } else {
            right = mid;
        }
    }
    return nums[left];
}

// [1, 2, 2, 2, 3, 1, 1, 1]
// worst case: [1, 1, 1, 1, 1, 1, ...., 1], from O(Log(N)) drops to O(N)
// http://www.jiuzhang.com/solutions/find-minimum-in-rotated-sorted-array-ii/
- (NSNumber *)findMinWithDuplicates:(NSArray<NSNumber *> *)nums {
    NSParameterAssert(nums);
    NSUInteger left = 0, right = nums.count-1;
    while (left < right) {
        NSUInteger mid = left + (right - left)/2;
        if ([nums[mid] compare:nums[right]] == NSOrderedDescending) {
            left = mid+1;
        } else if ([nums[mid] compare:nums[right]] == NSOrderedAscending){
            right = mid;
        } else { // equal
            right--; // when middle value equals to right value, just move right to left by 1
        }
    }
    return nums[left];
}

==============================================================================

Question 16: Paint House I [DP] [DONE]
 
There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.

The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses.

// Dynamic Programming question
// After thinking, this question is similar to "best time of sell stock" question
// For each house, we have three choices: paint red, blue and green
// we use three arrays for tracking three DP lines
// http://www.cnblogs.com/grandyang/p/5319384.html
- (NSUInteger)minCost:(NSUInteger [][3])costs n:(NSUInteger)n {
	// three status for painting ith house
	NSUInteger red[n+1], blue[n+1], green[n+1];
	red[0] = blue[0] = green[0] = NSUIntegerMax;
	for (NSUInteger i=1; i<n+1; i++) {
		// if the ith house painted into red color, then (i-1)th house must be blue or green
		// NOTICE: index of costs should be i-1, not i
		red[i] = MIN(blue[i-1]+costs[i-1][0], green[i-1]+costs[i-1][0]);
		blue[i] = MIN(red[i-1]+costs[i-1][1], green[i-1]+costs[i-1][1]);
		green[i] = MIN(red[i-1]+costs[i-1][2], blue[i-1]+costs[i-1][2]);
	}
	return MIN(red[n], MIN(blue[n], green[n]));
}

- (NSUInteger)minCostInPlace:(NSUInteger [][3])costs n:(NSUInteger)n {
	for (NSUInteger i=1; i<n; i++) {
		costs[i][0] += MIN(costs[i-1][1], costs[i-1][2]);
		costs[i][1] += MIN(costs[i-1][0], costs[i-1][2]);
		costs[i][2] += MIN(costs[i-1][0], costs[i-1][1]);
	}
	return MIN(MIN(costs[n-1][0], costs[n-1][1]), costs[n-1][2]);
}

==============================================================================

Question 17: Paint House II [DP] [DONE]
 
There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.

The cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses.

Follow up:
Could you solve it in O(nk) runtime?

https://discuss.leetcode.com/topic/22580/ac-java-solution-without-extra-space
http://www.jiuzhang.com/solutions/paint-house-ii/
// Idea: dynamic programming, cache previous minimum and second minimum {color id, cost}
// if current color id equals to previous minimum, then use second minimum; Otherwise, use previous minimum

@interface PreviousMinimumCost : NSObject

@property (nonatomic, assign) NSUInteger color;
@property (nonatomic, assign) NSUInteger cost;

+ (instancetype)empty;
+ (instancetype)cost:(NSUInteger)cost color:(NSUInteger)color;

@end

- (NSUInteger)minCostII:(NSUInteger **)costs n:(NSUInteger)n k:(NSUInteger)k {
    NSUInteger dp[n+1][k];
    memset(dp, 0, sizeof(dp));
    // "now" calculates three most minimum cost for ith house among k colors
    // then "last" store these value for calculating (i+1)th house
    NSMutableArray<PreviousMinimumCost *> *now = [NSMutableArray array];
    NSArray<PreviousMinimumCost *> *last = nil;
    [now addObject:[PreviousMinimumCost empty]];
    [now addObject:[PreviousMinimumCost empty]];
    [now addObject:[PreviousMinimumCost empty]];
    
    for (NSUInteger i=1; i<=n; i++) {
        last = [now copy];
        now[0] = [PreviousMinimumCost empty];
        now[1] = [PreviousMinimumCost empty];
        for (NSUInteger j=0; j<k; j++) {
            // current color is different from last color
            if (j != last[0].color) {
                dp[i][j] = dp[i-1][last[0].color] + costs[i-1][j];
            } else {
                dp[i][j] = dp[i-1][last[1].color] + costs[i-1][j];
            }
            now[2] = [PreviousMinimumCost cost:dp[i][j] color:j];
            NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@"cost" ascending:YES];
            [now sortUsingDescriptors:@[sortDescriptor]];
        }
    }
    return now[0].cost;
}

==============================================================================

Question 19: Coin Change [DP] [DONE]

You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:
coins = [1, 2, 5], amount = 11
return 3 (11 = 5 + 5 + 1)

Example 2:
coins = [2], amount = 3
return -1.

Note:
You may assume that you have an infinite number of each kind of coin.

// Traditional Dynamic Programming question
// Tricky part:
// - the index of DP[] stands for the target total amount; 
// - the value of DP[] stands for the minimum count of coins
// Ask interviewer: coins sorted? coin value type? target amount size?
// https://leetcode.com/problems/coin-change/?tab=Solutions
- (NSInteger)coinChange:(NSArray<NSNumber *> *)coins amount:(NSUInteger)amount {
    // NOTICE: how about amount == NSUIntegerMax ? discuss with interviewer
    // variable length C array should not be initialized with "{ value }";
    NSUInteger dp[amount+1];
    memset(dp, amount+1, amount+1);
    dp[0] = 0;
    for (NSUInteger i=1; i<=amount; i++) {
        NSUInteger n = coins.count;
        for (NSUInteger j=0; j<n; j++) {
            NSUInteger curC = coins[j].unsignedIntegerValue;
            if (curC <= i) dp[i] = MIN(dp[i], dp[i-curC]+1);
        }
    }
    return dp[amount] <= amount ?: -1;
}

==============================================================================

Question 21: Move Zeroes [DONE]

Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.
For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].
Note: You must do this in-place without making a copy of the array. Minimize the total number of operations.

// Very traditional question, MUST do in perfect way.
// Ask interviewer: how about nil ? zero count ?
// http://www.jiuzhang.com/solutions/move-zeroes/
- (void)moveZeros:(NSMutableArray<NSNumber *> *)nums {
    NSParameterAssert(nums);
    NSUInteger zero = 0;
    for (NSUInteger nonZero = 0; nonZero<nums.count; nonZero++) {
        if (![nums[nonZero] isEqualToNumber:@(0)]) {
            [nums exchangeObjectAtIndex:nonZero withObjectAtIndex:zero];
            zero++;
        }
    }
}

==============================================================================

Question 23: 3Sum [DONE]

Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note: The solution set must not contain duplicate triplets.

For example, given array S = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]

Similar Questions:
- 3Sum Cloest: https://leetcode.com/problems/3sum-closest/?tab=Solutions
- 3Sum Small: http://www.cnblogs.com/grandyang/p/5235086.html
- NOTICE: 1) for 3Sum Cloest and 3Sum Small, we don't need to remove duplicates
- 2)for 3Sum Cloest, remember to use "ABS" for calculating the value

// By brute force, this question can be solved with O(N^3)
// Better idea: we sort the array first, then using three pointers (one head, one tail, and one mid)
// Then we reduce the time complexity into O(N^2 + NLog(N))
// NOTICE: remove duplicates by moving pointers until no duplicates, then calculate
// Ask interviewer: duplicates in array? order of output?
// http://www.jiuzhang.com/solutions/3sum/
// https://leetcode.com/problems/3sum/?tab=Solutions

- (NSArray<NSArray<NSNumber *> *> *)threeSum:(NSArray<NSNumber *> *)nums {
	if (!nums) return nil;

    NSMutableArray<NSNumber *> *sortedNums = [NSMutableArray arrayWithArray:nums];
    NSSortDescriptor *descriptor = [NSSortDescriptor sortDescriptorWithKey:nil ascending:YES];
    [sortedNums sortUsingDescriptors:@[descriptor]];
    
    NSUInteger size = nums.count;
    NSMutableArray<NSArray<NSNumber *> *> *results = [NSMutableArray array];
    
    for (NSUInteger start=0; start<size-2; start++) {
        // if found duplicates, ignore and continue
        if (start > 0 && [sortedNums[start] isEqualToNumber:sortedNums[start-1]]) continue;
        NSUInteger mid = start+1;
        NSUInteger end = size-1;
        NSInteger target = -sortedNums[start].integerValue;
        while (mid < end) {
            if (sortedNums[mid].integerValue + sortedNums[end].integerValue == target) {
                [results addObject:@[sortedNums[start], sortedNums[mid], sortedNums[end]]];
                mid++; end--;
                // now skip duplicates
                while (mid < end && sortedNums[mid] == sortedNums[mid-1]) mid++;
                while (mid < end && sortedNums[end] == sortedNums[end+1]) end--;
            } else if (sortedNums[mid].integerValue + sortedNums[end].integerValue < target) {
                mid++;
            } else {
                end--;
            }
        }
    }
    return results;
}

==============================================================================

Question 24: 4Sum I [DONE]

Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note: The solution set must not contain duplicate quadruplets.

For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]

// Similar to 3Sum, but now we use two front points instead of one
// Brute Force: O(N^4)
// Better idea: sort and reach N^3 + NLog(N)
// http://www.jiuzhang.com/solutions/4sum/

- (NSArray<NSArray<NSNumber *> *> *)fourSum:(NSArray<NSNumber *> *)nums target:(NSInteger)target {
    if (!nums) return nil;
    
    NSMutableArray<NSNumber *> *sortedNums = [NSMutableArray arrayWithArray:nums];
    NSSortDescriptor *descriptor = [NSSortDescriptor sortDescriptorWithKey:nil ascending:YES];
    [sortedNums sortUsingDescriptors:@[descriptor]];
    
    NSMutableArray<NSArray *> *results = [NSMutableArray array];
    NSUInteger size = nums.count;
    for (NSUInteger first=0; first<size-3; first++) {
        if (first > 0 && [sortedNums[first] isEqualToNumber:sortedNums[first-1]]) continue;
        for (NSUInteger second = first+1; second < size-2; second++) {
            if (second > first+1 && [sortedNums[second] isEqualToNumber:sortedNums[second-1]]) continue;
            NSInteger sum = target - sortedNums[first].integerValue - sortedNums[second].integerValue;
            NSUInteger third = second+1;
            NSUInteger fourth = size-1;
            while (third < fourth) {
                if (sortedNums[third].integerValue + sortedNums[fourth].integerValue == sum) {
                    [results addObject:@[sortedNums[first], sortedNums[second],
                                         sortedNums[third], sortedNums[fourth]]];
                    third++; fourth--;
                    while (third < fourth && [sortedNums[third] isEqualToNumber:sortedNums[third-1]]) third++;
                    while (third < fourth && [sortedNums[fourth] isEqualToNumber:sortedNums[fourth-1]]) fourth--;
                } else if (sortedNums[third].integerValue + sortedNums[fourth].integerValue < sum) {
                    third++;
                } else {
                    fourth--;
                }
            }
        }
    }
    return results;
}

==============================================================================

Question 25: 4Sum II [DONE]

Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.

To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.

Example:

Input:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

Output:
2

Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0

// Brute force: O(N^4) -> too slow
// Better idea: we change this to 2Sum question. first get sum of A and B, and count them in a hash table
// Then calculate C + D, and find if target-(C+D) exists in hash table
// O(N^2)

- (NSUInteger) fourSumCountAmongA:(NSArray<NSNumber *> *)A B:(NSArray<NSNumber *> *)B
                              C:(NSArray<NSNumber *> *)C D:(NSArray<NSNumber *> *)D {
    NSParameterAssert(A && B && C && D);
    NSMutableDictionary<NSNumber *, NSNumber *> *count = [NSMutableDictionary dictionary];
    for (NSUInteger i=0; i<A.count; i++) {
        for (NSUInteger j=0; j<B.count; j++) {
            NSInteger sum = A[i].integerValue + B[j].integerValue;
            count[@(sum)] = @(count[@(sum)].integerValue + 1);
        }
    }
    
    NSUInteger result = 0;
    for (NSUInteger i=0; i<C.count; i++) {
        for (NSUInteger j=0; j<D.count; j++) {
            NSInteger sum = C[i].integerValue + D[j].integerValue;
            if (count[@(-sum)]) {
                result = count[@(-sum)].integerValue;
            }
        }
    }
    return result;
}

==============================================================================

Question 28: Merge Sorted Array [DONE]

Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.

// Ask interviewer: duplicates? input valid? ascending or descending
// We know that nums1 array has more than or equal m+n space, so we iterate based on nums2
// we put merged numbers into nums1 from back to front
// when all numbers from nums2 have been merged into nums1, then we just keep the rest numbers
// in nums1 at their place.

- (void)merge:(NSInteger *)nums1 and:(NSInteger *)nums2 m:(NSUInteger)m n:(NSUInteger)n {
    if (nums1 == nil || nums2 == nil || m == 0 || n == 0) return;
    NSInteger end1 = m-1, end2 = n-1, end = m+n-1;
    while (end2 >= 0) {
        if (end1 >= 0) {
            nums1[end--] = nums1[end1] > nums2[end2] ? nums1[end1--] : nums2[end2--];
        } else {
            nums1[end--] = nums2[end2--];
        }
    }
}

==============================================================================

Question 32: Longest Consecutive Sequence [DONE]
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

For example,
Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.

Your algorithm should run in O(n) complexity.

// Ask interviewer: any duplicate? can not use sort for sure.
// http://www.jiuzhang.com/solutions/longest-consecutive-sequence/
// https://leetcode.com/problems/longest-consecutive-sequence/?tab=Solutions
// Idea: use hash table/set to hold numbers. when we see N in the set, we check ALL its upper
// and lower consecutive neighbors and remove then from the set.
// because we scale the size of set down, so the running time is about O(N)

- (NSUInteger)longestConsecutive:(NSArray<NSNumber *> *)nums {
	NSMutableSet<NSNumber *> *set = [NSMutableSet setWithArray:nums];
	NSUInteger longest = 0;
	for (NSInteger i=0; i<nums.count; i++) {
		NSNumber *down = @(nums[i].integerValue-1);
		while ([set containsObject:down]) {
			[set removeObject:down];
			down = @(down.integerValue-1);
		}
		
		NSNumber *up = @(nums[i].integerValue+1);
		while ([set containsObject:up]) {
			[set removeObject:up];
			up = @(up.integerValue+1);
		}
		longest = MAX(longest, up.integerValue - down.integerValue - 1);
	}
	return longest;
}

==============================================================================

Question 33: Maximum Subarray [DONE]

Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.

// Traditional Dynamic Programming Question
// Ask interviewer: nil handling? positive, negative?

- (NSInteger)maxSubArray(NSArray<NSNumber *> *)nums {
	if (!nums) return NSIntegerMin;
	NSInteger maxCur = NSIntegerMin;
	NSInteger maxSoFar = NSIntegerMin;
	for (NSInteger i=0; i<nums.count; i++) {
		maxCur = MAX(maxCur + nums[i].integerValue, nums[i].integerValue);
		maxSoFar = MAX(maxCur, maxSoFar);
	}
	return maxSoFar;
}

==============================================================================

Question 34: Subarray with sum equals to K [DONE]

Whether there is a subarray's sum equals to k, here all numbers are non-negative numbers.

For example: [2, 3, 1, 2, 4, 5, 6], k = 10

http://www.1point3acres.com/bbs/thread-206502-1-1.html

// Because for this question, all numbers are positive numbers.
// So we can use Slide Window to find the answer

- (BOOL)subArrayInArray:(NSArray<NSNumber *> *)nums sum:(NSUInteger)k {
    if (nums == nil || nums.count == 0) return NO;
    NSInteger sum = 0;
    NSUInteger start = 0;
    for (NSInteger end = 0; end<nums.count; end++) {
        sum += nums[end].integerValue;
        if (sum == k) {
            return YES;
        }
        while (sum > k && start <= end) {
            sum -= nums[start++].integerValue;
        }
    }
    return NO;
}

==============================================================================

Question 35: Maximum Size Subarray Sum Equals k [DONE]
 
Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.

Note:
The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.

Example 1:
Given nums = [1, -1, 5, -2, 3], k = 3,
return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)

// http://www.programcreek.com/2014/10/leetcode-maximum-size-subarray-sum-equals-k-java/
// https://discuss.leetcode.com/topic/33259/o-n-super-clean-9-line-java-solution-with-hashmap

- (NSUInteger)maximumSizeSubarrayInArray:(NSArray<NSNumber *> *)nums k:(NSInteger)k {
    NSMutableDictionary<NSNumber *, NSNumber *> *preSums = [NSMutableDictionary dictionary];
    NSUInteger maxSize = 0;
    NSInteger sum = 0;
    for (NSInteger i = 0; i<nums.count; i++) {
        sum += nums[i].integerValue;
        if (sum == k) maxSize = MAX(maxSize, i+1);
        if (preSums[@(sum-k)]) maxSize = MAX(maxSize, i-preSums[@(sum-k)].integerValue);
        if (!preSums[@(sum)]) preSums[@(sum)] = @(i);
    }
    return maxSize;
}

==============================================================================

Question 36: Submatrix with sum equals to K [DONE]

Given a n×nn×n matrix A[0...m-1][0....n-1] where all entries are non-negative integers, and a non-negative integer K, find whether there is submatrix with sum to K

http://www.1point3acres.com/bbs/thread-206502-1-1.html
CC150 page 492

// Naive solution: O(M^2*N^2) -> O(N^4)
// - we make two outer for loops to traverse all nodes in the matrix left to right
// - then we use two inner for loops to traverse sub matrixes from current node left to right,
//   and calculate sum for each sub matrix. If sum equals to K, we return YES.
// Better solution: O(N^3)
// - We all know the solution of "Question 34: Subarray with sum equals to K", which works well for 1-dimension
//   array.
// - Now we have a two dimension matrix. So we need to think "how to downgrade it into 1-dimension question."
// - We calculate sum for each column from "start row" to "end row" column by column
// - Then we use "subarray with sum equals to K" solution for this "column sum array" between "start row" and 	  //   "end row"
// NOTICE: we MUST make sure that all matrix node should be non-negative numbers

- (BOOL)subMatrixOfMatrix:(NSArray<NSArray<NSNumber *> *> *)matrix k:(NSUInteger)k {
    if (matrix == nil) return NO;
    NSUInteger m = matrix.count;
    if (m == 0) return NO;
    NSUInteger n = matrix[0].count;
    NSMutableArray<NSNumber *> *partialSums = [NSMutableArray array];
    for (NSInteger rowStart=0; rowStart<m; rowStart++) {
        // remove all objects for each iteration
        [partialSums removeAllObjects];
        for (NSInteger rowEnd=rowStart; rowEnd<m; rowEnd++) {
            for (NSInteger col=0; col<n; col++) {
                partialSums[col] = @(partialSums[col].integerValue + matrix[rowEnd][col].integerValue);
            }
            BOOL found = [self subArrayInArray:partialSums sum:k];
            if (found) return YES;
        }
    }
    return NO;
}

- (BOOL)subArrayInArray:(NSArray<NSNumber *> *)nums sum:(NSUInteger)k {
    if (nums == nil || nums.count == 0) return NO;
    NSInteger sum = 0;
    NSUInteger start = 0;
    for (NSInteger end = 0; end<nums.count; end++) {
        sum += nums[end].integerValue;
        if (sum == k) {
            return YES;
        }
        while (sum > k && start <= end) {
            sum -= nums[start++].integerValue;
        }
    }
    return NO;
}

==============================================================================

Question 40: Merge K Sorted Arrays/Linked Lists [DONE]

Merge k sorted Arrays/Linked Lists and return it as one sorted Array/List

http://www.programcreek.com/2014/05/merge-k-sorted-arrays-in-java/

// Priority Queue question.
// Also can be done by Binary Search Tree in my opinion

==============================================================================

Question 42: Best Time to Buy and Sell Stock [DP] [DONE]

Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Example 1:
Input: [7, 1, 5, 3, 6, 4]
Output: 5

max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
Example 2:
Input: [7, 6, 4, 3, 1]
Output: 0

In this case, no transaction is done, i.e. max profit = 0.

// Idea: keep tracking the minimum price of the stock. Then sell on highest price after it.
// Ask interviewer: prices are positive or negative or both? All integers? handling 0 count or 1 count

- (NSInteger)maxProfit:(NSArray<NSNumber *> *)prices {
	if (prices == nil || prices.count == 0) return NSIntegerMin;
	NSInteger maxProfit = NSIntegerMin;
	NSInteger minPrice = NSIntegerMax;
	for (NSInteger i=0; i<prices.count; i++) {
		NSInteger price = prices[i].integerValue;
		minPrice = MIN(price, minPrice);
		maxProfit = MAX(maxProfit, price-minPrice);
	}
	return maxProfit;
}

==============================================================================

Question 44: Contains Duplicate III [DONE]

Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.

// When we see "at most" keywords, one thing we can guess is Slide Window
// Ask interviewer: is the array sorted or not? any duplicate?
// For this question, there are "Heap" solution and "Bucket" solution
// For objective-c, "binary search" solution is more straight forward.
// NSOrderedSet is a great class for handling order of hashed unique objects
// Idea: https://leetcode.com/problems/contains-duplicate-iii/?tab=Solutions
// - keep a "Window set" which tracking at most k recent numbers
// - insert each number into window set by binary search, in order to keep the set sorted
// - we know that "|x - nums[i]| <= t" means "-t <= x - nums[i] <= t"
// - we first find x from window set, which "x - nums[i] >= -t" ==> "x >= nums[i]-t"
// - then we confirm that "there is such x in windows set" and also "x - nums[i] <= t"
// - if so, we return YES. Otherwise we insert nums[i] into window set, and loop.
// - if loop completes, we return NO

- (BOOL)containsNearbyAlmostDuplicate:(NSArray<NSNumber *> *)nums k:(NSInteger)k t:(NSInteger)t {
    NSMutableOrderedSet<NSNumber *> *window = [NSMutableOrderedSet orderedSet];
    for (NSInteger i=0; i<nums.count; i++) {
        // i == k -> k-1 elements
        if (i>k) [window removeObject:nums[i-k-1]];
        NSInteger num = nums[i].integerValue;
        // find the insertion index of num-t
        NSUInteger pos = [window indexOfObject:@(num - t)
                                 inSortedRange:NSMakeRange(0,window.count)
                                       options:NSBinarySearchingInsertionIndex
                               usingComparator:^NSComparisonResult(NSNumber *num1, NSNumber *num2) {
                                   return [num1 compare:num2];
                               }];
        // if there are numbers larger than num - t, also that number is smaller or equal than num+t
        // then we find the result, and return
        if ((pos != window.count-1) && (window[pos].integerValue - num <= t)) return YES;
        // if not found any result, then we insert the number into the sorted ordered set
        // in this way, we can always keep the window set sorted
        pos = [window indexOfObject:@(num)
                      inSortedRange:NSMakeRange(0,window.count)
                            options:NSBinarySearchingInsertionIndex
                    usingComparator:^NSComparisonResult(NSNumber *num1, NSNumber *num2) {
                        return [num1 compare:num2];
                    }];
        [window insertObject:@(num) atIndex:pos];
    }
    return NO;
}

==============================================================================

Question 45: Check Duplicate Numbers In Window k [DONE]
http://www.geeksforgeeks.org/check-given-array-contains-duplicate-elements-within-k-distance/

Given an unsorted array that may contain duplicates. Also given a number k which is smaller than size of array. Write a function that returns true if array contains duplicates within k distance.

Examples:

Input: k = 3, arr[] = {1, 2, 3, 4, 1, 2, 3, 4}
Output: false
All duplicates are more than k distance away.

Input: k = 3, arr[] = {1, 2, 3, 1, 4, 5}
Output: true
1 is repeated at distance 3.

Input: k = 3, arr[] = {1, 2, 3, 4, 5}
Output: false

Input: k = 3, arr[] = {1, 2, 3, 4, 4}
Output: true

// Similar question to "Question 43: Contains Duplicate III"
// we can use a window set to keep tracking number we met at most k element before
// Ask interviewer: is k valid? nil handling?

- (BOOL)checkDuplicatesWithinK:(NSArray<NSNumber *> *)nums k:(NSUInteger)k {
    NSMutableOrderedSet<NSNumber *> *window = [NSMutableOrderedSet orderedSet];
    for (NSInteger i=0; i<nums.count; i++) {
        if (i > k) [window removeObjectAtIndex:i-k-1];
        NSNumber *num = nums[i];
        if ([window containsObject:num]) return YES;
        [window addObject:num];
    }
    return NO;
}

==============================================================================

Question 47: First Bad Version [DONE]

You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

// Traditional binary search question.
// NOTICE: be careful about upper_bound or lower_lound. 

BOOL isBadVersion(NSUInteger version);

- (NSUInteger)firstBadVersion:(NSUInteger)n {
    NSInteger left = 1; // NOTICE
    NSInteger right = n;
    while(left < right) {
        NSInteger mid = left + (right-left)/2;
        if (!isBadVersion(mid)) left = mid+1;
        else right = mid;
    }
    return left;
}

==============================================================================

Question 48: Dot Product Of Sparse Vector [DONE]

Given two sparse Vectors, compute the Dot Product. 

For example: [1, 3, 2, 3, 4, 3, 4] and [0, 0, 0, 2, 0, 1, 0, 0]

http://www.1point3acres.com/bbs/thread-117371-1-1.html
https://discuss.leetcode.com/topic/199/dot-product-of-sparse-vector/2
https://www.careercup.com/question?id=5678837729853440

Similar Question: Sparse Matrix multiplication
// Solutions:
// http://www.jiuzhang.com/solutions/sparse-matrix-multiplication/
// http://buttercola.blogspot.fi/2016/01/leetcode-sparse-matrix-multiplication.html

// Actually Vector is 1 dimension Matrix.
// When we see "Sparse Matrix", which contains many '0's, 
// we could use Hash Table/Adjacent List to save memory space, also increase algorithm efficiency.
// Also if we do it without extra memory, we should check '0's in the more sparse matrix,
// and skip them during calculation.


==============================================================================

Question 49: Sparse Matrix Multiplication [DONE]

Given two sparse matrices A and B, return the result of AB.
You may assume that A's column number is equal to B's row number.

Example:
A = [
  [ 1, 0, 0],
  [-1, 0, 3]
]

B = [
  [ 7, 0, 0 ],
  [ 0, 0, 0 ],
  [ 0, 0, 1 ]
]


     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |
AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |
                  | 0 0 1 |
				  
// Similar with Question 48

==============================================================================

Question 50: Longest Increasing(Arithmetic) Subsequence I [DONE]

Given an unsorted array of integers, find the length of longest increasing subsequence.

For example,
Given [10, 9, 2, 5, 3, 7, 101, 18],
The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.

Your algorithm should run in O(n^2) complexity.

Follow up: Could you improve it to O(n log n) time complexity?

// "Longest" incidates the possibility of using "Dynamic Programming"
// Ask interviewer: positive, negative? sorted? size? duplicates?
// Naive Solution: two for loop to check from beginning to the end
// Better solution: dynamic programming. But even with dynamic programming, time complexity is still O(N^2)
// we need binary search to decrease it to O(NLog(N))
// in order to use binary search, we MUST have a sorted array.
// http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/
// NOTICE:
// - The result is NOT the real result. 
// - Only the "Length Of The Result" is the same as the length of final result.
// http://www.jiuzhang.com/solutions/longest-increasing-subsequence/
// http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/

O(N^2)
- (NSUInteger)lengthOfLISDP:(NSArray<NSNumber *> *)nums {
    if (!nums || nums.count == 0) return 0;
    NSUInteger dp[nums.count];
    NSUInteger max = 0;
    for (NSInteger i=1; i<nums.count; i++) {
        dp[i] = 1;
        for (NSInteger j=i-1; j>=0; j++) {
            NSInteger num = nums[i].integerValue;
            if (num > nums[j].integerValue) dp[i] = MAX(dp[j]+1, dp[i]);
        }
        if (dp[i] > max) max = dp[i];
    }
    return max;
}

/*Our strategy determined by the following conditions,
 
 1. If A[i] is smallest among all end
 candidates of active lists, we will start
 new active list of length 1, but still keep rest in the array,
 which stands for the current maximum value
 2. If A[i] is largest among all end candidates of
 active lists, we will clone the largest active
 list, and extend it by A[i].
 
 3. If A[i] is in between, we will find a list with
 largest end element that is smaller than A[i].
 Clone and extend this list by A[i]. We will discard all
 other lists of same length as that of this modified list.*/

O(NLogN)
- (NSUInteger)lengthOfLISBinarySearch:(NSArray<NSNumber *> *)nums {
    NSMutableArray<NSNumber *> *fakeResults = [NSMutableArray array];
    for (NSInteger i=0; i<nums.count; i++) {
        NSNumber *num = nums[i];
        // find insertion index
        NSUInteger idx = [fakeResults indexOfObject:num inSortedRange:NSMakeRange(0,fakeResults.count)
                                            options:NSBinarySearchingInsertionIndex
                                         usingComparator:^NSComparisonResult(NSNumber *num1, NSNumber *num2) {
                                             return [num1 compare:num2];
                                         }];
        if (idx == fakeResults.count) [fakeResults addObject:num];
        else fakeResults[i] = num;
    }
    // The result is NOT the real result.
    // Only the "Length Of The Result" is the same as the length of final result.
    return fakeResults.count;
}

==============================================================================

Question 52: Word Search [DONE]

Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

For example,
Given board =

[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "ABCCED", -> returns true,
word = "SEE", -> returns true,
word = "ABCB", -> returns false.

// Ask interviewer: capital letter? all inputs valid?
// Traditional DFS + Backtracking solution O(M*N*4*k) = O(kN^2)
// NOTICE: we can decrease space consumption by mark visited node in the board
// for example, mark it into '#' and change it back after tracking back.
// https://leetcode.com/problems/word-search/?tab=Solutions
// http://www.jiuzhang.com/solutions/word-search/

- (BOOL)exist:(NSArray<NSArray<NSString *> *> *)board word:(NSString *)word {
    if (board == nil || word == nil || word.length == 0) return NO;
    NSUInteger m = board.count;
    if (m == 0) return NO;
    NSUInteger n = board[0].count;
    NSString *firstC = [word substringWithRange:NSMakeRange(0,1)];
    for (NSInteger i=0; i<m; i++) {
        for (NSInteger j=0; j<n; j++) {
            NSString *c = board[i][j];
            NSMutableSet<NSValue *> *visited = [NSMutableSet set];
            if ([c isEqualToString:firstC]) {
                BOOL found = [self dfs:board i:i j:j word:word start:0 visited:visited];
                if (found) return YES;
            }
        }
    }
    return NO;
}

- (BOOL)dfs:(NSArray<NSArray<NSString *> *> *)board
          i:(NSInteger)i j:(NSInteger)j
       word:(NSString *)word
      start:(NSUInteger)start
    visited:(NSMutableSet<NSValue *> *)visited {
    if (start == word.length) return YES;
    if (i>board.count-1 || i<0 || j>board[0].count-1 || j<0) return NO;
    // for iOS, use valueWithCGPoint and NSMakeCGPoint
    NSValue *pos = [NSValue valueWithPoint:NSMakePoint(i, j)];
    if ([visited containsObject:pos]) return NO;
    [visited addObject:pos];
    
    NSString *bc = board[i][j];
    NSString *sc = [word substringWithRange:NSMakeRange(start,1)];
    if (![bc isEqualToString:sc]) return NO;
    // go left, right, up and down
    return [self dfs:board i:i+1 j:j word:word start:start+1 visited:visited] ||
    [self dfs:board i:i-1 j:j word:word start:start+1 visited:visited] ||
    [self dfs:board i:i j:j+1 word:word start:start+1 visited:visited] ||
    [self dfs:board i:i j:j-1 word:word start:start+1 visited:visited];
}

==============================================================================

Question 52: Word Search II [DONE]

Given a 2D board and a list of words from the dictionary, find all words in the board.

Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

For example,
Given words = ["oath","pea","eat","rain"] and board =

[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
Return ["eat","oath"].

Note: You may assume that all inputs are consist of lowercase letters a-z.

// If we use solution in Question 51, and search word by word, 
// then the time complexity will be extremely high.
// for string searching, we can use Trie to compress and store the whole dictionary words
// the searching time for a word will drop to O(M), where M is the average length of words.
// So Trie + Backtracking is a good solution.
// NOTICE: we DON'T implement Trie structure here.
// http://www.jiuzhang.com/solutions/word-search-ii/

- (NSArray<NSString *> *)findWords:(NSArray<NSString *> *)words
                           inBoard:(NSArray<NSArray<NSString *> *> *)board {
    if (board == nil || words == nil || words.count == 0) return NO;
    NSUInteger m = board.count;
    if (m == 0) return NO;
    NSUInteger n = board[0].count;
    
    // first, we create the Trie
    Trie *trie = [Trie trie];
    for (NSInteger i=0; i<words.count; i++) {
        [trie addWord:words[i]];
    }
    
    // we use set here to avoid duplicates
    NSMutableSet<NSString *> *results = [NSMutableSet set];
    // then, we still do dfs
    for (NSInteger i=0; i<m; i++) {
        for (NSInteger j=0; j<n; j++) {
            NSMutableSet<NSValue *> *visited = [NSMutableSet set];
            [self dfs:board i:i j:j word:board[i][j] trieNode:trie.root
              visited:visited results:results];
        }
    }
    return [results allObjects];
}

- (void)dfs:(NSArray<NSArray<NSString *> *> *)board
          i:(NSInteger)i j:(NSInteger)j
       word:(NSString *)word
   trieNode:(TrieNode *)trieNode
    visited:(NSMutableSet<NSValue *> *)visited
    results:(NSMutableSet<NSString *> *)results {
    if (i>board.count-1 || i<0 || j>board[0].count-1 || j<0) return;
	
    // for iOS, use valueWithCGPoint and NSMakeCGPoint
    NSValue *pos = [NSValue valueWithPoint:NSMakePoint(i, j)];
    if ([visited containsObject:pos]) return;
    [visited addObject:pos];
    
    unichar c = [board[i][j] characterAtIndex:0];
    if (![trieNode hasChild:c]) return;
    NSString *nextWord = [word stringByAppendingString:board[i][j]];
    TrieNode *nextNode = [trieNode getChild:c];
    if (nextNode.isWord) [results addObject:nextWord];
    
	// WRONG HERE: We need to remove "pos" from visited after each recersive call
    [self dfs:board i:i+1 j:j word:nextWord trieNode:nextNode visited:visited results:results];
    [self dfs:board i:i-1 j:j word:nextWord trieNode:nextNode visited:visited results:results];
    [self dfs:board i:i j:j+1 word:nextWord trieNode:nextNode visited:visited results:results];
    [self dfs:board i:i j:j-1 word:nextWord trieNode:nextNode visited:visited results:results];
}

==============================================================================

Question 53: Combination Sum IV [DONE]

Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.

Example:

nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.

Follow up:

What if negative numbers are allowed in the given array?
How does it change the problem?
What limitation we need to add to the question to allow negative numbers?

// Ask interviewer: sorted?
// This kind of question can usually be solved by:
// - DP: when solve the problem return the count
// - DFS : for return all the possible result
// https://discuss.leetcode.com/topic/52542/c-template-for-all-combination-problem-set (nice summury)
// Thinking for follow up: 
// - because for this question, there is no "length limitation" for the results, 
//   then when we have negative numbers, there will be "infinite length".
// - for example [2, -2, 2, -2], target is 3
// - we can add like "same number can not be used twice" to allow negative numbers.
// NOTICE: for this DP question, the index if the "target value", not "index of nums"

- (NSUInteger)combinationSum4DP:(NSArray<NSNumber *> *)nums target:(NSUInteger)target {
    NSUInteger dp[target+1];
    dp[0] = 1;
	NSSortDescriptor *sd = [NSSortDescriptor sortDescriptorWithKey:nil ascending:YES];
	NSArray *sortedNums = [nums sortedArrayUsingDescriptors:@[sd]];
    for (NSInteger i=0; i<=target; i++) {
        for (NSInteger j=0; j<sortedNums.count; j++) {
            if (i > sortedNums[j].integerValue) dp[i] += dp[i-sortedNums[j].integerValue];
        }
    }
    return dp[target];
}

// how about outputing all possible combinations?
- (NSArray<NSArray<NSNumber *> *> *)combinationSumDFS:(NSArray<NSNumber *> *)nums target:(NSUInteger)target {
    NSMutableArray<NSArray<NSNumber *> *> *results = [NSMutableArray array];
    [self helper:nums target:target combination:[NSMutableArray array] results:results];
    return results;
}

- (void)helper:(NSArray<NSNumber *> *)nums target:(NSInteger)target
   combination:(NSMutableArray<NSNumber *> *)combination
       results:(NSMutableArray<NSArray<NSNumber *> *> *)results {
    if (target < 0) return;
    if (target == 0) [results addObject:[combination copy]];
    for (NSInteger i=0; i<nums.count; i++) {
        NSInteger num = nums[i].integerValue;
        [combination addObject:nums[i]];
        [self helper:nums target:target-num combination:combination results:results];
        [combination removeLastObject];
    }
}

==============================================================================

Question 60: Combination Sum [DONE]

Given a set of candidate numbers (C) (without duplicates) and a target number (T), 
find all unique combinations in C where the candidate numbers sums to T.

The same repeated number may be chosen from C unlimited number of times.

Note: 
All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
For example, given candidate set [2, 3, 6, 7] and target 7, 
A solution set is: 

[
  [7],
  [2, 2, 3]
]

// Ask interviewer: is [2, 3, 2] same as [2, 2, 3]?
// From the question we know that we need to output all results
// So usually this can be solved by "Backtracking" + "DFS"

- (NSArray<NSArray<NSNumber *> *> *)combinationSumI:(NSArray<NSNumber *> *)candidates
                                             target:(NSInteger)target {
    NSParameterAssert(candidates);
    NSMutableArray<NSArray<NSNumber *> *> *results = [NSMutableArray array];
    [self dfs:candidates target:target begin:0
	 combination:[NSMutableArray array] results:results];
    return results;
}

// this implementation assumes that [2, 3, 2] equals to [2, 2, 3]
// So we need a "begin" index to avoid this duplicate situation.
- (void)dfs:(NSArray<NSNumber *> *)candidates target:(NSInteger)target
      begin:(NSInteger)begin
combination:(NSMutableArray *)combination
    results:(NSMutableArray<NSArray<NSNumber *> *> *)results {
    if (target < 0) return;
  	 if (target == 0) {
         [results addObject:[combination copy]];
         return;
     }
    
    // because we use "begin" to move the begin pointer, then we can have
    // [2, 2, 2, 2], [3, 3, 3, 3] [6, 6, 6, 6], etc
    for (NSInteger i=begin; i<candidates.count; i++) {
        [combination addObject:candidates[i]];
        [self dfs:candidates target:target-candidates[i].integerValue begin:i
      combination:combination results:results];
        [combination removeLastObject];
    }
}

==============================================================================

Question 62: Merge Intervals [DONE]

Given a collection of intervals, merge all overlapping intervals.

For example,

Given [1,3],[2,6],[8,10],[15,18],
return [1,6],[8,10],[15,18].

// For interval merging questions, "Sorting" is a handy tool.
// Ask interviewer: input valid? [1, 1] possible?
// clean solution by checking and updating "last interval" in the array: 
// https://leetcode.com/problems/merge-intervals/?tab=Solutions

- (NSArray<Interval *> *)merge:(NSArray<Interval *> *)intervals {
    if (intervals == nil || intervals.count == 0) return intervals;
    
    NSComparator cmp = ^NSComparisonResult(Interval *i1, Interval *i2) {
        // sort the list based on the interval start
        return i1.start < i2.start;
    };
    
    NSArray<Interval *> *sorted = [intervals sortedArrayUsingComparator:cmp];
    NSMutableArray<Interval *> *results = [NSMutableArray array];
    
    NSInteger start = intervals[0].start, end = intervals[0].end;
    for (NSInteger i=1; i<sorted.count; i++) {
        Interval *cur = intervals[i];
        // if there is overlapping, then we merge them
        if (cur.start<=end) {
            end = MAX(cur.end, end);
        } else { // if there isn't overlapping, then we start a new interval
            [results addObject:[Interval intervalWithStart:start end:end]];
            start = cur.start;
            end = cur.end;
        }
    }
    // REMEMBER: add the last interval
    [results addObject:[Interval intervalWithStart:start end:end]];
    return results;
}

==============================================================================

Question 63: Search in Rotated Sorted Array [DONE]

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

// When we meet searching in "sorted" array questions, no matter if it is rotated or not,
// "Binary Search" will be the great tool for solving this kind of questions.
// Ask interviewer: duplicates? positive or negative? handling invalid input?
// Very clever solution for uing NSIntegerMin and NSIntegerMax to change this question into normal-
// binary earch question: https://discuss.leetcode.com/topic/34491/clever-idea-making-it-simple/2

- (NSInteger)search:(NSArray<NSNumber *> *)nums target:(NSInteger)target {
    if (nums == nil && nums.count == 0) return -1;
    NSInteger left = 0, right = nums.count-1;
    while (left <= right) {
        NSInteger mid = left + (right-left)/2;
        NSInteger midValue = nums[mid].integerValue;
        NSInteger leftValue = nums[left].integerValue;
        NSInteger rightValue = nums[right].integerValue;
        
        if (midValue == target) return mid;
        
        // checking middle value with left value is logically better than
        // checking middle value and target
        if (midValue >= leftValue) {
            if (target < midValue && target >= leftValue) {
                right = mid-1;
            } else {
                left = mid+1;
            }
        } else {
            if (target > midValue && target <= rightValue) {
                left = mid+1;
            } else {
                right = mid-1;
            }
        }
    }
    return -1;
}

==============================================================================

Question 64: Search in Rotated Sorted Array II [DONE]

Follow up for "Search in Rotated Sorted Array": What if duplicates are allowed?

Would this affect the run-time complexity? How and why?
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Write a function to determine if a given target is in the array.

The array may contain duplicates.

// The idea is similar to previous question.
// we still do the binary search, but first filter out all duplicates.
// The worst time complexity will drop to O(N) from O(LogN), for example [1, 1, 1, 1, 1, 1]

- (BOOL)searchWithDuplicate:(NSArray<NSNumber *> *)nums target:(NSInteger)target {
    if (nums == nil && nums.count == 0) return -1;
    NSInteger left = 0, right = nums.count-1;
    while (left <= right) {
        NSInteger mid = left + (right-left)/2;
        NSInteger midValue = nums[mid].integerValue;
        NSInteger leftValue = nums[left].integerValue;
        NSInteger rightValue = nums[right].integerValue;
        
        if (midValue == target) return mid;
        
        // checking middle value with left value is logically better than
        // checking middle value and target
        if (midValue > leftValue) {
            if (target < midValue && target >= leftValue) {
                right = mid-1;
            } else {
                left = mid+1;
            }
        } else if (midValue < leftValue) {
            if (target > midValue && target <= rightValue) {
                left = mid+1;
            } else {
                right = mid-1;
            }
        } else {
			// when we find duplications, just left to right until no duplicate anymore
			leftValue += 1;
		}
    }
    return -1;
}

==============================================================================

Question 70: Intersection of Two Arrays II [DONE]

Given two arrays, write a function to compute their intersection.

Example:
Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].

Note:
Each element in the result should appear as many times as it shows in both arrays.
The result can be in any order.

Follow up:
- What if the given array is already sorted? How would you optimize your algorithm?
- What if nums1's size is small compared to nums2's size? Which algorithm is better?
- What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?

// Basic idea: use hash table to count one array, and find duplicates in another one -> O(m+n)
// Follow up: 
// - if arrays are sorted, we can use binary search to find each number -> O(max(mlogn, nlogm))
// - if nums 1 is small compared to nums2, then binary search is faster
// - If only nums2 cannot fit in memory, put all elements of nums1 into a HashMap, 
// read chunks of array that fit into the memory, and record the intersections.
// - If both nums1 and nums2 are so huge that neither fit into the memory, 
// sort them individually (external sort), then read 2 elements from each array at a time in memory, 
// record intersections.

- (NSArray<NSNumber *> *)intersection:(NSArray<NSNumber *> *)nums1 nums2:(NSArray<NSNumber *> *)nums2 {
    if (nums1.count >= nums2.count) {
        return [self intersection:nums2 nums2:nums1];
    }
    NSMutableDictionary<NSNumber *, NSNumber *> *count = [NSMutableDictionary dictionary];
    NSMutableArray<NSNumber *> *results = [NSMutableArray array];
    for(NSNumber *num in nums1) {
        if (count[num] == nil) count[num] = @(0);
        count[num] = @(count[num].integerValue+1);
    }
    
    for (NSNumber *num in nums2) {
        if (count[num] && count[num].integerValue > 0) {
            [results addObject:num];
            count[num] = @(count[num].integerValue-1);
        }
    }
    return results;
}

==============================================================================

Question 72: Median of Two Sorted Arrays [Hard] [DONE]

There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

Example 1:
nums1 = [1, 3]
nums2 = [2]

The median is 2.0
Example 2:
nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5

// Ask interviewer: duplicates?
// First, let's see the concept of 'MEDIAN' in a slightly unconventional way. That is:
// "if we cut the sorted array to two halves of EQUAL LENGTHS, then
// median is the AVERAGE OF Max(lower_half) and Min(upper_half), i.e. the
// two numbers immediately next to the cut".
// (L + R)/2 = (A[(N-1)/2] + A[N/2])/2

// https://discuss.leetcode.com/topic/16797/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation
// http://www.geeksforgeeks.org/median-of-two-sorted-arrays/
// http://www.geeksforgeeks.org/median-of-two-sorted-arrays-of-different-sizes/

- (NSNumber *)findMedianSortedArrays:(NSArray<NSNumber *> *)nums1 nums2:(NSArray<NSNumber *> *)nums2 {
	// TODO
}

==============================================================================

Question 73: Sorted Squares of Sorted Numbers [DONE]

We're given a sorted array of integers: [-3, -1, 0, 1, 2]. We want to generate a sorted array of their squares: [0, 1, 1, 4, 9]

// This is double pointer question
// be careful that if -3*-3 = 6, 2*2 = 4
// So we need to compare them from left and right towards middle
// One solution is to sort the array based on "absolute value", [0, 1, -1, 2, -3], then calculate squares
// this takes O(nlogn + n) time
// NOTICE: 
// - if input is "Array", we can directly use double pointer solution
// - if input is "Linked List", then we need to use double runner, and split the list into two parts,
//   then reverse second part.
// https://www.careercup.com/question?id=5681516425248768

- (NSArray<NSNumber *> *)sortedSquaresOfSortedNumbers:(NSArray<NSNumber *> *)nums {
    if (nums == nil) return nil;
    NSMutableArray<NSNumber *> *results = [NSMutableArray array];
    NSInteger left=0, right=nums.count-1;
    while (left < right) {
        NSNumber *leftNum = nums[left];
        NSNumber *rightNum = nums[right];
        if (ABS(leftNum.integerValue) >= ABS(rightNum.integerValue)) {
            [results addObject:@(leftNum.integerValue * leftNum.integerValue)];
            left++;
        } else {
            [results addObject:@(rightNum.integerValue * rightNum.integerValue)];
            right--;
        }
    }
    return results;
}

==============================================================================

Question 80: Subsets [DONE]

Given a set of distinct integers, nums, return all possible subsets.

Note: The solution set must not contain duplicate subsets.

For example,
If nums = [1,2,3], a solution is:

[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

// Ask interviewer: does output order matter? duplicates?
// Similar solution with "push / pop" solution:
// https://discuss.leetcode.com/topic/19110/c-recursive-iterative-bit-manipulation-solutions-with-explanations

- (NSArray<NSArray<NSNumber *> *> *)subsetsBacktracking:(NSArray<NSNumber *> *)nums {
	if (nums == nil || nums.count == 0) return nil;
	return [self helper:nums start:0];
}

- (NSArray<NSArray<NSNumber *> *> *)helper:(NSArray<NSNumber *> *)nums start:(NSInteger)start {
	if (start == nums.count) return @[@[]];
	NSMutableArray<NSArray<NSNumber *> *> *results = [NSMutableArray array];
	for (NSInteger i=start; i<nums.count; i++) {
		// first we add the single number into result
		NSArray<NSArray<NSNumber *> *> *combines = [self helper:nums start:i+1];
		for (NSArray<NSNumber *> *combine in combines) {
			[results addObject:[@[nums[i]] arrayByAddingObjectsFromArray:combine]];
		}
	}
	return results;
}

- (NSArray<NSArray<NSNumber *> *> *)subsetsIterative:(NSArray<NSNumber *> *)nums {
	NSMutableArray<NSArray<NSNumber *> *> *results = [NSMutableArray arrayWithObject:@[]];
	for (NSInteger i=0; i<nums.count; i++) {
		NSInteger n = results.count;
		for (NSInteger j=0; j<n; j++) {
			NSMutableArray<NSNumber *> *combine = [results[j] mutableCopy];
			[combine addObject:nums[i]];
			[results addObject:combine];
		}
	}
	return results;
}

==============================================================================

Question 81: Subsets II [DONE]

Given a collection of integers that might contain duplicates, nums, return all possible subsets.

Note: The solution set must not contain duplicate subsets.

For example,
If nums = [1,2,2], a solution is:

[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]

// Similar to Subsets I
// The only difference is that in this question, we need to skip duplicates
// we just need to check: index != begin && nums[index] == nums[index-1]
// NOTICE: we need to "sort" the array with duplicates first!
// For recursion + backtracking solution, the duplicate checking is easier:
// https://discuss.leetcode.com/topic/13543/accepted-10ms-c-solution-use-backtracking-only-10-lines-easy-understand

- (NSArray<NSArray<NSNumber *> *> *)subsetsWithDuplicate:(NSArray<NSNumber *> *)nums {
    NSSortDescriptor *descriptor = [NSSortDescriptor sortDescriptorWithKey:nil ascending:YES];
    NSArray<NSNumber *> *sortedNums = [nums sortedArrayUsingDescriptors:@[descriptor]];
    
    NSMutableArray<NSArray<NSNumber *> *> *results = [NSMutableArray arrayWithObject:@[]];
    // previousSize still store the previous results size
    // the startIndex stands for the startIndex of previous results for combining next subsets
    NSInteger previousSize = 0, startIndex = 0;
    for (NSInteger i=0; i<sortedNums.count; i++) {
        // if we find duplication, then we just combine with the last one of previous results
        if (i >= 1 && nums[i].integerValue == nums[i-1].integerValue) startIndex = previousSize;
        else startIndex = 0;
        previousSize = results.count;
        for (NSInteger j=startIndex; j<previousSize; j++) {
            NSMutableArray<NSNumber *> *combine = [results[j] mutableCopy];
            [combine addObject:nums[i]];
            [results addObject:combine];
        }
    }
    return results;
}

==============================================================================

Question 83: Meeting Rooms [DONE]
 
Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), determine if a person could attend all meetings. For example, Given [[0, 30],[5, 10],[15, 20]], return false.

// Sort and check interval overlaps exists or not.
// http://www.programcreek.com/2014/07/leetcode-meeting-rooms-java/

==============================================================================

Question 84: Meeting Rooms II [DONE]
 
Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] find the minimum number of conference rooms required.

// http://www.cnblogs.com/grandyang/p/5244720.html
// https://discuss.leetcode.com/topic/35253/explanation-of-super-easy-java-solution-beats-98-8-from-pinkfloyda/2
// For "two array solution", the reason "why we move both i and endItr pointer together when start[i] > 
// end[endItr]", is because end[endItr] will free a meeting room, and at same time, start[i] will occupy
// that meeting room. So 1-1 = 0.

==============================================================================

Question 87: Ugly Number II [DONE]

Write a program to find the n-th ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.

Note that 1 is typically treated as an ugly number, and n does not exceed 1690.

// https://discuss.leetcode.com/topic/21882/my-16ms-c-dp-solution-with-short-explanation

==============================================================================

Question 88: Sort Transformed Array [DONE]

Given a sorted array of integers nums and integer values a, b and c. Apply a function of the form f(x) = ax2 + bx + c to each element x in the array.

The returned array must be in sorted order.

Expected time complexity: O(n)

Example:
nums = [-4, -2, 2, 4], a = 1, b = 3, c = 5,

Result: [3, 9, 15, 33]

nums = [-4, -2, 2, 4], a = -1, b = 3, c = 5

Result: [-23, -5, 1, 7]

// http://www.cnblogs.com/grandyang/p/5595614.html

==============================================================================

Question 94: Check an array increment or decrement

==============================================================================

Question 100: 给一串start time - end time，格式是Apr 2010 - Mar 2011这种，要求计算出这些时间的总跨度，重叠的跨度不重复计算。举例:["Apr 2010 - Dec 2010", "Aug 2010 - Dec 2010", "Jan 2011 - Mar 2011"]这一个string数组，结果为(12-4+3-1)=10个月。

// 1) string to integer (date)
// 2) merge interval
// 3) sum intervals

==============================================================================

Question 105: 一个array, [1,3,5,7,4,8,2], 一个 target k, 找出这个array里所有子集的个数，满足:子集里最小和最大的数相加小于等于k.. 

先排序。binarysearch找k在数组里的位置，然后左右指针。 小难点在去重。比如k=7，算[1,2,3,4,5]时为了保证1存在，只算[2,3,4,5]排列的个数。算[2,3,4,5]时，只算[3,4,5]排列的个数。

==============================================================================

Question 109: input 是array {1，2，3，0，4}。到达最后一个格子最短步数，每个数字代表最多可以跳几下。 [DONE]

==============================================================================

Question 113: Matrix中有0和1， 求1组成的最大的plus (+)形状的长度.

==============================================================================

Question 117: list of sorted integer arrays，要求找所有的数的median. e.g. [1,3,6,7,9], [2,4, 8], [5], return 5

==============================================================================

Question 118: Unique Paths I/II

==============================================================================

Question 121: 给出N个序列，比如2个序列A,B,没个序列包含若干的区间，
比如 A: [1,5], [10,14], [16,18]
B: [2,6], [8,10], [11,20]
Merge them all: [1,6], [8, 20].

==============================================================================

Question 122: 给三个funtions: is_low(), is_mid(), is_high(). 让给一个数组排序, low的放在最前面, mid的放在中间, high的放在最后面. Color sort: think about when there are K colors

==============================================================================

Question 124: House Robber [DP] [DONE]

https://leetcode.com/problems/house-robber/#/description

==============================================================================

Question 125: implement circular array: Circular buffer

==============================================================================

Question 128: Previous Permutation，7531->7513

==============================================================================

Question 129: 给一个一维的整数组，在每两个数之填上“+”，“-”，或者什么都不填(也就是和前面数字结合)，这样得到一个公式，求出结果可以是0的公式数量。

==============================================================================

Question 134: Erase duplicate in an unsorted array

==============================================================================

